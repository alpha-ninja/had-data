<!doctype html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if IE 9]>    <html class="no-js ie9" lang="en"> <![endif]-->
<!--[if gt IE 9]><!--> <html class="no-js" lang="en" ng-app="buildlogApp"> <!--<![endif]-->
<head>
    
    <title>Project logs &bull; FlexSEA: Wearable robotics toolkit &bull; Hackaday.io</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="//cdn.hackaday.io/css/style.css?version=0.48.6" />
    <script type="text/javascript" src="//use.typekit.net/ymb0lgk.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
</head>
<body class="logs">

    <!--
############################################################################################
############################################################################################
############################################################################################
#####################Kt;tL#######################################Kti,E######################
#######################;   .###################################G    E#######################
#######################K    f##################################    ;########################
########################Wj   E###############################K:  .W#########################
##########################.  :E##############################:  .L##########################
#########################D    f##############################.   .##########################
########################,     ;##############################     :E#######K################
################f######K      ,##############################      ,######Lt################
################  W###W       i##############################       t####j t################
################:  E#L.        f###########################L.        f#Ki .E################
################j  ;E.          j##########################.         .G;  i#################
#################L               i#######################K                ##################
#################W                E#####################K;               ;##################
###################:               .###################D               :f###################
#####################DLfGD           G####WEEEEKW####W           ;GffGK#####################
##########################i         iD##Kfi    :jKW##D          iE##########################
###########################W      ,G##f            jE#E;       j############################
############################L     D##D              ,##K       W############################
#############################D:  G#W                  K#E,   G##############################
###############################;i#L                    j## ,E###############################
###############################KK#.                     ##iE################################
#################################j                      ;K##################################
################################W                        ,##################################
################################E                         ##################################
###############################Ki                         D#################################
###############################E.                         L#################################
###############################f    iD##W;       D###D    :#################################
###############################i   i######K     K#####K;   #################################
###############################;  .E#######     #######D   #################################
###############################;  L########     ########   #################################
###############################i  G#######K     K#######   #################################
###############################j  L#####E,       fE#####   #################################
###############################D  .E##j            .t##E  ;#################################
###############################E:  ;##.              #Wt  j#################################
################################G   ;t      tWi      t    E#################################
#############################KL##           K#K;          #K:K##############################
#############################i ##:          ###t         j#f ;K#############################
############################:  G#K          #E#L        L##    D############################
###########################D   ;W#:         #;#L        W#K    .############################
#####################KKEKK      :##L        ; ..      :D##.      fKEEK######################
###################t.            ;##G:               ,##E,             tD###################
##################G               E##E               i##;               :###################
#################D                W##W    iL    E.    ###D                ##################
################W,               G###W    tG    K.    ####:               K#################
################;  LW;         ,E#####:  ;W#    #G   f#####;         ;KG  :K################
################  D###E       ;########WW####WW####WW#######W       :####: j################
################ ,#####:      ;##############################       G####E i################
################K#######.     ;##############################      L######WG################
########################f     i##############################     j#########################
#########################W   .D##############################.   i##########################
#########################E   G###############################D   ,##########################
########################G:   #################################j   G#########################
#######################f    K##################################j    W#######################
#####################Kt :iE#####################################KL:  K######################
############################################################################################
############################################################################################
############################################################################################
-->

<div class="header" id="header">
    <div class="container">
        <h1 class="logo">
            <a href="/" title="Hackaday.io Home" class="home" onclick="CT(this, 'Menu', 'Home'); return false;"></a>
            <a href="/" title="Hackaday.io Home" class="brand" onclick="CT(this, 'Menu', 'Home'); return false;">Hack a Day</a>
        </h1>

        <a href="javascript:void(0);" class="responsive-menu">Menu</a>

        <ul class="nav" role="navigation">
            <li><a href="/projects" class="">Projects</a></li>
            <li><a href="/lists" class="">Lists</a></li>
            <li><a href="/stack" class="">Stack</a></li>
            <li class="dropdown more-nav j-more-open">
                <a href="javascript:void(0)" class="dropdown-link icon-dropdown">More</a>
                <ul role="menu" class="dropdown-menu more-menu" id="j-more">
                    <li><a href="http://hackaday.com/blog/" target="_blank">Blog</a></li>
                    <li><a href="/events">Events</a></li>
                    <li><a href="/hackerspaces">Hackerspaces</a></li>
                    <li><a href="/hackers">Profiles</a></li>
                    <li><a href="/contests">Contests</a></li>
                    <li><a href="/prize" target="_blank">The Hackaday Prize</a></li>
                    <li><a href="/submissions/prize2015/list">2015 Prize Entries</a></li>
                </ul>
            </li>
            <li class="menu-last-child">
                <div class="search-holder show">
                    <form id="search-form" action="/search" onsubmit="return submitSearch();" method="GET">
                        <input type="text" placeholder="Search" name="term" class="input-search j-add-search" id="j-add-search" value="" autocomplete="off" pattern=".{3,}" required title="3 characters minimum" />
                        <input type="submit" class="search-button" />
                    </form>
                </div>
            </li>
        </ul>

        

            <ul class="nav pull-right" role="navigation">
                <li><a href="/signup" class="grey-white-button become-member">Sign up</a></li>
                <li><a href="/signin?returnUrl=%2Fproject%2F5765%2Flogs">Sign in</a></li>
            </ul>

        
    </div>
</div>

<div id="topMessage" class="alert"><span class="j-top-content"></span><a href="javascript:void(0);" class="alert-close j-top-message-close">Close</a></div>




    <div class="headline">
        <div class="container">
            <h2><a href="/project/5765-flexsea-wearable-robotics-toolkit">FlexSEA: Wearable robotics toolkit</a></h2>
            <p class="description-title"> Project logs</p>
            <p class="description-summary">OSHW+OSS to enable the next generation of powered prosthetic limbs and exoskeletons. Let’s make humans faster/better/stronger!</p>
            <div class="description-metainfo">
                
                    <span>created by <a href="/hacker/62343-jean-franois-duval" title="Visit Profile">Jean-François Duval</a><span>&bull;</span>
                
                3 months ago<span>&bull;</span><a href="/project/5765#discussion-list" title="See Comments">3 Comments</a></span>
            </div>
        </div>
    </div>

    <div class="container post-content">
        <div class="section-buildsort">
            <span class="pull-left">
                <a href="/project/5765-flexsea-wearable-robotics-toolkit">&#171; Back to project details</a>
            </span>
            <span class="sort-holder pull-right">
                <label for="sort-by">Sort by:</label>
                <select class="sort" id="sort-by">
                    <option value="/project/5765/logs/sort/newest">Newest</option>
                    <option value="/project/5765/logs/sort/oldest" selected="selected">Oldest</option>
                </select>
            </span>
        </div>
        <div class="section section-buildlogs last">
            

                <ul class="buillogs-list">
                    
                        <li>
                            <h2><a href="/project/5765/log/17751-flexsea-overview">FlexSEA Overview</a></h2>
                            <small class="authorship">3 months ago  &bull;
                                <a class="gray-link" href="/project/5765/log/17751#discussion-list">
                                    0 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-17751"><p>There are two main ways of designing electronic architectures for active wearable robotics: 1) microcontroller-based and 2) embedded computer-based. Commercial products are mostly microcontroller-based while research prototypes tend to favor systems with embedded computers. <br></p><table> <tbody><tr> <td> <p><b>Microcontroller</b></p> </td> <td> <p><b>Embedded Computer</b></p> </td> </tr> <tr> <td colspan="2"> <p><i>Pros</i></p> </td> </tr> <tr> <td> <ul><li>Small form factor that can easily be adapted to different mechanical designs</li> <li>Low power</li> <li>Unit cost is low</li> <li>Low level software (C and/or ASM): processor efficient</li> </ul></td> <td> <li>Quick design phase</li> <li>High-level software (C++, Python, Java, Matlab): ease of development</li> <li>Minimize the number of specialized skills required to modify the system</li> </td> </tr> <tr> <td colspan="2"> <p><i>Cons</i></p> </td> </tr> <tr> <td> <ul><li>Development (prototyping) cost can be higher</li> <li>Longer design phase</li> <li>Requires Electrical Engineering skills for the design, maintenance and modification</li> <li>Low level software (C and/or ASM): less portable, requires specialized skills</li> </ul></td> <td> <li>High-level software (C++, Python, Java, Matlab): not processor efficient</li> <li>Higher power (less energy efficient)</li> <li>Relies on commercial parts (no control over the production and life cycle)</li> <li>Harder to modify</li> <li>Integration issues between different subsystems</li> <li>Sub optimal wiring</li> </td> </tr></tbody></table><p>FlexSEA combines the two major embedded system design approaches. Commercial products are usually microcontroller-based. They can have small form factors, low power requirements and a low unit cost but programming them, adding sensors and motors or networking multiple circuits together requires specialized skills or extensive circuit and system redesign. On the other end, research prototypes often use embedded computers as the main computing element. The design phase is short and high-level software can be used but the mechanical integration is problematic, the power consumption is high, interconnections lack reliability and there is no clear path towards commercialization. FlexSEA combines the two approaches, keeping only the best features.</p><p><img src="https://cdn.hackaday.io/images/4501291431451955407.png"></p><a name="_Toc418851388">FlexSEA-Plan</a><p>FlexSEA-Plan is an embedded computer used for high-level computing. It boasts a powerful processor and can run an operating system such as Linux. Developing code on this platform is similar to the regular (i.e. non-embedded) software development process. High-level languages such as Python can be used, saving experimental data is as simple as writing to a text file and interacting with the system can be done via USB or WiFi. FlexSEA-Plan should be used when ease of development is important, and when complex algorithms and control schemes require significant computing power. </p><a name="OLE_LINK4"></a><a name="_Toc418851389">FlexSEA-Manage</a><p>FlexSEA-Manage is used for mid-level computing tasks. It serves as an interface between FlexSEA-Plan and FlexSEA-Execute: communication protocols translation, data routing, time-sharing. It has an Expansion connector that can interface with a wide variety of input and output devices. Data acquisition, processing, and aggregation can be done on this board, thus unloading FlexSEA-Plan from these simple tasks. For applications that do not require intensive computing, FlexSEA-Plan can be taken out of the system and FlexSEA-Manage can host the high-level state machines.</p><a name="OLE_LINK5"></a><a name="_Toc418851390">FlexSEA-Execute</a><p>FlexSEA-Execute is an advanced brushless motor driver. Wearable robotics applications require different control loops than the typical position and current controllers found on commercial drives. FlexSEA-Execute has onboard sensors (6-axis IMU, temperature, voltage, current), interfaces (strain gauge amplifier), processing power and connectivity to make it possible to close most control loops onboard. It is well suited for the series elastic actuators (SEA) commonly used in prostheses. </p></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/5765/log/17755-flexsea-execute-01-advanced-motion-controller">FlexSEA-Execute 0.1: Advanced motion controller </a></h2>
                            <small class="authorship">3 months ago  &bull;
                                <a class="gray-link" href="/project/5765/log/17755#discussion-list">
                                    0 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-17755"><p>At its core, the FlexSEA-Execute board is a BLDC motor driver. It is specialized for robotic and prosthetic applications. The high level design goals were to maximize the system integration (small physical dimensions, large number of integrated peripherals and interfaces, support for external input and output devices), allow fast communication and networkability via the use of a fast multi-drop communication interface, and have built-in safety features. The design went through three major revisions; this document focuses on the last generation (FlexSEA-Execute 0.1).</p><p><img src="https://cdn.hackaday.io/images/3800331431452426293.png"></p><p>The next figure presents the logical organization of the FlexSEA-Execute 0.1 board. In orange are the schematic sheets and in grey are the sub-circuits present on certain sheets.</p><p><img src="https://cdn.hackaday.io/images/8472041431452482299.png"></p><br>The safety system is extremely important. The next diagram highlights the safety related features:<p><img src="https://cdn.hackaday.io/images/5675261431452536814.png"></p><table> <tbody><tr> <td rowspan="4"> <p>Electrical specifications</p> </td> <td> <p>Supply voltage (V)</p> </td> <td> <p>15-24V</p> </td> </tr> <tr> <td> <p>Motor current (A)</p> </td> <td> <p>20A Continuous</p> </td> </tr> <tr> <td> <p>Intermediate supply</p> </td> <td> <p>10V 500mA SMPS</p> </td> </tr> <tr> <td> <p>Logic supply</p> </td> <td> <p>5V 500mA SMPS</p> </td> </tr> <tr> <td rowspan="4"> <p>Motor</p> </td> <td> <p>Type</p> </td> <td> <p>3-phase brushless (BLDC)</p> </td> </tr> <tr> <td> <p>Sensor(s)</p> </td> <td> <p>Hall effect, optical encoder</p> </td> </tr> <tr> <td> <p>Commutation</p> </td> <td> <p>Block, Sinusoidal, FOC</p> </td> </tr> <tr> <td> <p>PWM</p> </td> <td> <p>12 bits 20kHz, 10 bits 78kHz or 9.65 bits 100kHz</p> </td> </tr> <tr> <td rowspan="5"> <p>Microcontroller</p> </td> <td> <p>Reference</p> </td> <td> <p>PSoC 5LP - CY8C5888AXI-LP096</p> </td> </tr> <tr> <td> <p>Special features</p> </td> <td> <p>Programmable analog and digital blocks</p> </td> </tr> <tr> <td> <p>CPU/RAM/IOs/Package</p> </td> <td> <p>80MHz ARM Cortex-M3, 256KB RAM, 62 IOs, TQFP</p> </td> </tr> <tr> <td> <p>Software / IDE</p> </td> <td> <p>PSoC Creator 3.1, mix of C (ARM GCC 4.7.3) and graphical programming.</p> </td> </tr> <tr> <td> <p>Co-processor(s)</p> </td> <td> <p>PSoC 4 - CY8C4245LQI-483</p> </td> </tr> <tr> <td rowspan="2"> <p>Serial interface</p> </td> <td> <p>Type</p> </td> <td> <p>3x Half-Duplex RS-485 (can be full-duplex synchronous)</p> </td> </tr> <tr> <td> <p>Bandwidth</p> </td> <td> <p>2-10Mbps</p> </td> </tr> <tr> <td> <p>Onboard USB</p> </td> <td></td> <td> <p>Full-Speed (FS) 12 Mbps</p> </td> </tr> <tr> <td rowspan="2"> <p>Current sensing</p> </td> <td> <p>Hardware</p> </td> <td> <p>0.005Ω resistor</p> </td> </tr> <tr> <td> <p>Software / control</p> </td> <td> <p>20kHz Proportional-Integral controller</p> </td> </tr> <tr> <td rowspan="5"> <p>Safety features</p> </td> <td> <p>Overvoltage</p> </td> <td> <p>TVS will clamp at 36V</p> </td> </tr> <tr> <td> <p>Overcurrent</p> </td> <td> <p>Software protection</p> </td> </tr> <tr> <td> <p>Locked rotor</p> </td> <td> <p>Hardware - lead shorting circuit</p> </td> </tr> <tr> <td> <p>Motor temperature</p> </td> <td> <p>Hardware measurement</p> </td> </tr> <tr> <td> <p>Board temperature</p> </td> <td> <p>CPU + bridge temperature reading</p> </td> </tr> <tr> <td> <p>Clutch</p> </td> <td></td> <td> <p>Variable voltage, 8-bits PWM, 400mA</p> </td> </tr> <tr> <td> <p>Strain gauge amplifier</p> </td> <td></td> <td> <p>Dual stage, 500 &lt; G &lt; 10000, high CMRR</p> </td> </tr> <tr> <td> <p>IO connector</p> </td> <td></td> <td> <p>Molex PicoClasp 40 positions, SMD 1mm pitch</p> </td> </tr> <tr> <td rowspan="5"> <p>External peripherals</p> </td> <td> <p>IOs available</p> </td> <td> <p>12</p> </td> </tr> <tr> <td> <p>Digital IOs</p> </td> <td> <p>Up to 12</p> </td> </tr> <tr> <td> <p>Analog inputs</p> </td> <td> <p>Up to 8 (12-bit SAR, 8-20-bits Sigma Delta)</p> </td> </tr> <tr> <td> <p>Serial</p> </td> <td> <p>I²C, SPI, UART</p> </td> </tr> <tr> <td> <p>Other</p> </td> <td> <p>1 optical encoder (A/B/I), 1 Hall effect encoder (3 pins)</p> </td> </tr> <tr> <td rowspan="3"> <p>Dimensions (mm)</p> </td> <td> <p>X (mm)</p> </td> <td> <p>49</p> </td> </tr> <tr> <td> <p>Y (mm)</p> </td> <td> <p>49</p> </td> </tr> <tr> <td> <p>Z (mm)</p> </td> <td> <p>From 12 to 15mm depending on capacitors</p> </td> </tr> <tr> <td rowspan="4"> <p>PCB technology</p> </td> <td> <p>Layers</p> </td> <td> <p>6</p> </td> </tr> <tr> <td> <p>Copper</p> </td> <td> <p>1 Oz</p> </td> </tr> <tr> <td> <p>Trace/space/via</p> </td> <td> <p>5/5 mils trace/space, 8/20 mils blind vias</p> </td> </tr> <tr> <td> <p>Assembly</p> </td> <td> <p>Double-sided</p> </td> </tr> <tr> <td> <p>Other</p> </td> <td></td> <td> <p>6-axis IMU, RGB LED</p> </td> </tr></tbody></table></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/5765/log/17756-flexsea-manage">FlexSEA-Manage</a></h2>
                            <small class="authorship">3 months ago  &bull;
                                <a class="gray-link" href="/project/5765/log/17756#discussion-list">
                                    0 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-17756"><p>FlexSEA-Manage is a polyvalent circuit that can have a wide range of usages depending on the system architecture. In the simplest system designs, it will act as a communication protocol translator, allowing Plan and Execute to communicate. When multiple FlexSEA-Execute are used, it routes packets, and can manage communication timings. It can be used to add extra sensors and output devices to the system. In systems that do not require the computing power of an embedded computer, Manage can host the high-level state machines.</p><p><img src="https://cdn.hackaday.io/images/6242721431452702507.png"></p><p>The following figure presents the hardware diagram of FlexSEA-Manage 0.1. In orange are the schematic sheets and in grey are the sub-circuits present on certain sheets.</p><p><img src="https://cdn.hackaday.io/images/6946291431452717471.png"></p><table> <tbody><tr> <td rowspan="2"> <p>Electrical specifications</p> </td> <td> <p>Supply voltage (V)</p> </td> <td> <p>5V in (from Plan or USB), on-board 3V3 regulator</p> </td> </tr> <tr> <td> <p>Current (mA)</p> </td> <td> <p>90mA</p> </td> </tr> <tr> <td rowspan="4"> <p>Microcontroller</p> </td> <td> <p>Reference</p> </td> <td> <p>STM32F427ZIT6</p> </td> </tr> <tr> <td> <p>Special features</p> </td> <td> <p>Floating-point co-processor can be software enabled.</p> </td> </tr> <tr> <td> <p>CPU/RAM/IOs/Package</p> </td> <td> <p>180MHz ARM Cortex-M4, 2MB FLASH, USB</p> </td> </tr> <tr> <td> <p>Software / IDE</p> </td> <td> <p>Eclipse C/C++, GNU Tools for ARM Embedded Processors (arm-none-eabi-gcc), OpenOCD GDB.</p> </td> </tr> <tr> <td rowspan="4"> <p>Serial interfaces</p> </td> <td> <p>Type</p> </td> <td> <p>2x [half-duplex, asynchronous full-duplex or synchronous full-duplex RS-485]</p> </td> </tr> <tr> <td> <p>Bandwidth</p> </td> <td> <p>2-10Mbps</p> </td> </tr> <tr> <td> <p>Type</p> </td> <td> <p>Full-duplex SPI</p> </td> </tr> <tr> <td> <p>Bandwidth</p> </td> <td> <p>20+ Mbps</p> </td> </tr> <tr> <td> <p>Onboard USB</p> </td> <td></td> <td> <p>Full-Speed (FS) / High-Speed (HS)</p> </td> </tr> <tr> <td rowspan="5"> <p>Peripherals / features</p> </td> <td> <p>FLASH memory</p> </td> <td> <p>128Mbits</p> </td> </tr> <tr> <td> <p>IMU</p> </td> <td> <p>6-axis (3x accelerometer, 3x gyroscope)</p> </td> </tr> <tr> <td> <p>Power output</p> </td> <td> <p>2x 24V 1A high-side switches</p> </td> </tr> <tr> <td> <p>LEDs</p> </td> <td> <p>2x green, 1x RGB</p> </td> </tr> <tr> <td> <p>Switches</p> </td> <td> <p>1x user input switch</p> </td> </tr> <tr> <td> <p>IO connector</p> </td> <td></td> <td> <p>Molex PicoClasp 40 positions, SMD 1mm pitch</p> </td> </tr> <tr> <td rowspan="4"> <p>External peripherals</p> </td> <td> <p>IOs available</p> </td> <td> <p>17, shared with functions below</p> </td> </tr> <tr> <td> <p>Digital IOs</p> </td> <td> <p>Up to 9, protected</p> </td> </tr> <tr> <td> <p>Analog inputs</p> </td> <td> <p>8x 12-bit SAR with special functions (filters, amplifiers, dividers, …)</p> </td> </tr> <tr> <td> <p>Serial</p> </td> <td> <p>I²C, SPI, USART</p> </td> </tr> <tr> <td rowspan="3"> <p>Dimensions (mm)</p> </td> <td> <p>X (mm)</p> </td> <td> <p>40</p> </td> </tr> <tr> <td> <p>Y (mm)</p> </td> <td> <p>40</p> </td> </tr> <tr> <td> <p>Z (mm)</p> </td> <td> <p>11.5</p> </td> </tr> <tr> <td rowspan="5"> <p>PCB technology</p> </td> <td> <p>Layers</p> </td> <td> <p>4</p> </td> </tr> <tr> <td> <p>Copper</p> </td> <td> <p>1Oz</p> </td> </tr> <tr> <td> <p>Trace/space/via</p> </td> <td> <p>5/5 mils trace/space, 8/20 mils vias</p> </td> </tr> <tr> <td> <p>Technology</p> </td> <td> <p>Standard</p> </td> </tr> <tr> <td> <p>Assembly</p> </td> <td> <p>Double-sided</p> </td> </tr></tbody></table></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/5765/log/18782-current-controller-hardware">Current controller: hardware</a></h2>
                            <small class="authorship">3 months ago  &bull;
                                <a class="gray-link" href="/project/5765/log/18782#discussion-list">
                                    0 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-18782"><p>Motor current sensing is an important feature for motor drivers. It is used as a safety feature to turn-off the PWM when excessive current is flowing through the driver, and to control the motor torque (torque is proportional to current). In this Project Log I'll detail how I implemented a high performance current controller on FlexSEA-Execute.</p><p>The programmable analog blocks of the PSoC can be used to design a small, low-cost motor current sensor. I started by doing an LTSpice simulation of the complete analog circuit:</p><p><img src="https://cdn.hackaday.io/images/8553601433172742669.png"></p><p><img src="https://cdn.hackaday.io/images/9529381433172764894.png"></p><p>0A will give me an output of 2.5V (half my ADC voltage supply), 20A = 0.5V and -20A = 4.5V. I kept a safety margin of 0.5V near each rail to account for component tolerances and to make sure that a small overcurrent wouldn't saturate the sensor.</p><p>In the PSoC we use one operational amplifier, one DAC and one analog multiplexer. In "real hardware", we only need one shunt resistor per bridge (), two resistors and one capacitor.</p><p>In PSoC hardware, the current sensing is strongly linked to all the motor control circuits: the following schematic has a lot of components!</p><p><img src="https://cdn.hackaday.io/images/4705691433172806080.png"></p><p><em>TLDR: with hardware, we amplify the current measurement, sample it at the PWM mid-point, convert it and trigger an interrupt every 5 samples.</em></p><p>I'll explain how the BLDC driver works in a different log; for now, let's focus on the current controller portion. PWM_1 is the 100kHz PWM signal used to control the motor speed. The pwm2 output will always go high at the mid-point of the active ON time (ie if my period is 10us and my duty-cycle is 50%, pwm will be initially off, then it will turn on at the 5us mark. pwm2 will become active at the 7.5us mark.) We use this rising edge to trigger ADC_SAR_2 (Sync_1 makes sure that the clocks are synchonized, otherwise we could miss pulses). The signal that is measured comes from Opamp_1; that's the opamp you saw on the LTSpice simulation. As you can see, an analog multiplexer (AmuxHw_1) is used to select one of the 3 sense resistors as the input of the amplifier. That selection is done in the LUT_4Q_PWM look-up table. We only read the leg that has its low-side switch turned on. Every 5th ADC sample a DMA interrupt is triggered. It calls the software current PI controller, for an effective refresh rate of 20kHz.</p><p>In <a href="https://hackaday.io/project/5765-flexsea-wearable-robotics-toolkit/log/18784-current-controller-software" target="_blank">Current controller: software</a> I cover the software aspect, and show you scope screen captures.</p></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/5765/log/18784-current-controller-software">Current controller: software</a></h2>
                            <small class="authorship">3 months ago  &bull;
                                <a class="gray-link" href="/project/5765/log/18784#discussion-list">
                                    2 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-18784"><p>Motor current sensing is an important feature for motor drivers. It is used as a safety feature to turn-off the PWM when excessive current is flowing through the driver, and to control the motor torque (torque is proportional to current). In this Project Log I'll detail how I implemented a high performance current controller on FlexSEA-Execute.</p><p>In <a href="https://hackaday.io/project/5765-flexsea-wearable-robotics-toolkit/log/18782-current-controller-hardware" target="_blank">Current controller: hardware</a> I covered the hardware. Now that we can accurately measure current we can control it. </p><p>Every 5th ADC sample a DMA interrupt occurs. This code is called:</p><pre class="hljs cpp">CY_ISR(isr_dma_Interrupt)
{
    <span class="hljs-comment">/*  Place your Interrupt code here. */</span>
    <span class="hljs-comment">/* `#START isr_dma_Interrupt` */</span>

	<span class="hljs-keyword">volatile</span> int32 adc_sum = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">volatile</span> int32 adc_avg = <span class="hljs-number">0</span>;
	
	<span class="hljs-comment">//Read last ADC value</span>
	adc_sum = (int32)(adc_dma_array[<span class="hljs-number">0</span>] + adc_dma_array[<span class="hljs-number">1</span>] + adc_dma_array[<span class="hljs-number">2</span>] + \
				adc_dma_array[<span class="hljs-number">3</span>] + adc_dma_array[<span class="hljs-number">4</span>]);
	adc_avg = (adc_sum / <span class="hljs-number">5</span>);
	
	ctrl.current.actual_val = (int32)(adc_avg - CURRENT_ZERO);	
	<span class="hljs-comment">//Used by the current controller, 0 centered.</span>
		
	<span class="hljs-keyword">if</span>((ctrl.active_ctrl == CTRL_CURRENT) || (ctrl.active_ctrl == CTRL_IMPEDANCE))
	{
		<span class="hljs-comment">//Current controller</span>
		motor_current_pid_2(ctrl.current.setpoint_val, ctrl.current.actual_val);
	}

    <span class="hljs-comment">/* `#END` */</span>
}
</pre><br><p> The last 5 values are averaged, and the current control function is called.</p><pre class="hljs cpp"><span class="hljs-comment">//PI Current controller #2: speed optimized</span>
<span class="hljs-comment">//'wanted_curr' &amp; 'measured_curr' are centered at zero and are in the ±CURRENT_SPAN range</span>
<span class="hljs-comment">//The sign of 'wanted_curr' will change the rotation direction, not the polarity of the current (I have no control on this)</span>
<span class="hljs-function"><span class="hljs-keyword">inline</span> int32 <span class="hljs-title">motor_current_pid_2</span><span class="hljs-params">(int32 wanted_curr, int32 measured_curr)</span>
</span>{
	<span class="hljs-keyword">volatile</span> int32 curr_p = <span class="hljs-number">0</span>, curr_i = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">volatile</span> int32 curr_pwm = <span class="hljs-number">0</span>;
	int32 sign = <span class="hljs-number">0</span>;
	int32 uint_wanted_curr = <span class="hljs-number">0</span>;
	int32 motor_current = <span class="hljs-number">0</span>;
	int32 shifted_measured_curr = <span class="hljs-number">0</span>;
	
	<span class="hljs-comment">//Clip out of range values</span>
	<span class="hljs-keyword">if</span>(wanted_curr &gt;= CURRENT_POS_LIMIT)
		wanted_curr = CURRENT_POS_LIMIT;
	<span class="hljs-keyword">if</span>(wanted_curr &lt;= CURRENT_NEG_LIMIT)
		wanted_curr = CURRENT_NEG_LIMIT;		
	ctrl.current.setpoint_val = wanted_curr;
	
	<span class="hljs-comment">//Sign extracted from wanted_curr:</span>
	<span class="hljs-keyword">if</span>(wanted_curr &lt; <span class="hljs-number">0</span>)
	{
		sign = -<span class="hljs-number">1</span>;
		MotorDirection_Control = <span class="hljs-number">0</span>;		<span class="hljs-comment">//MotorDirection_Write(0);</span>
		uint_wanted_curr = -wanted_curr;
	}
	<span class="hljs-keyword">else</span>
	{
		sign = <span class="hljs-number">1</span>;
		MotorDirection_Control = <span class="hljs-number">1</span>;		<span class="hljs-comment">//MotorDirection_Write(1);</span>
		uint_wanted_curr = wanted_curr;
	}
	
	<span class="hljs-comment">//At this point 'uint_wanted_curr' is always a positive value.</span>
	<span class="hljs-comment">//This is our setpoint.</span>
	
	<span class="hljs-comment">//From ADC value to motor current:</span>
	shifted_measured_curr = measured_curr + CURRENT_ZERO;
	<span class="hljs-keyword">if</span>(shifted_measured_curr &lt;= CURRENT_ZERO)
	{
		<span class="hljs-comment">//We are driving the motor (Q1 or Q3)</span>
		motor_current = CURRENT_ZERO - shifted_measured_curr;
	}
	<span class="hljs-keyword">else</span>
	{
		motor_current =  shifted_measured_curr - CURRENT_ZERO;
	}
	<span class="hljs-comment">//ToDo above code seems complex for no valid reason</span>
	
	<span class="hljs-comment">//At this point 'motor_current' is always a positive value.</span>
	<span class="hljs-comment">//This is our measured value.</span>
	
	<span class="hljs-comment">//Error and integral of errors:</span>
	ctrl.current.error = uint_wanted_curr - motor_current;					<span class="hljs-comment">//Actual error</span>
	ctrl.current.error_sum = ctrl.current.error_sum + ctrl.current.error;	<span class="hljs-comment">//Cumulative error</span>
	
	<span class="hljs-comment">//Saturate cumulative error</span>
	<span class="hljs-keyword">if</span>(ctrl.current.error_sum &gt;= MAX_CUMULATIVE_ERROR)
		ctrl.current.error_sum = MAX_CUMULATIVE_ERROR;
	<span class="hljs-keyword">if</span>(ctrl.current.error_sum &lt;= -MAX_CUMULATIVE_ERROR)
		ctrl.current.error_sum = -MAX_CUMULATIVE_ERROR;
	
	<span class="hljs-comment">//Proportional term</span>
	curr_p = (<span class="hljs-keyword">int</span>) (ctrl.current.gain.I_KP * ctrl.current.error) / <span class="hljs-number">100</span>;
	<span class="hljs-comment">//Integral term</span>
	curr_i = (<span class="hljs-keyword">int</span>)(ctrl.current.gain.I_KI * ctrl.current.error_sum) / <span class="hljs-number">100</span>;
	<span class="hljs-comment">//Add differential term here if needed</span>
	<span class="hljs-comment">//In both cases we divide by 100 to get a finer gain adjustement w/ integer values.</span>
	
	<span class="hljs-comment">//Output</span>
	curr_pwm = curr_p + curr_i;
	
	<span class="hljs-comment">//Saturates PWM</span>
	<span class="hljs-keyword">if</span>(curr_pwm &gt;= POS_PWM_LIMIT)
		curr_pwm = POS_PWM_LIMIT;
	<span class="hljs-keyword">if</span>(curr_pwm &lt;= <span class="hljs-number">0</span>)	<span class="hljs-comment">//Should not happen</span>
		curr_pwm = <span class="hljs-number">0</span>;
	
	<span class="hljs-comment">//Apply PWM</span>
	<span class="hljs-comment">//motor_open_speed_2(curr_pwm, sign);</span>
	<span class="hljs-comment">//Integrated to avoid a function call and a double saturation:</span>
	
	<span class="hljs-comment">//Write duty cycle to PWM module (avoiding double function calls)</span>
	curr_pwm = PWM1DC(curr_pwm);
	CY_SET_REG16(PWM_1_COMPARE1_LSB_PTR, (uint16)curr_pwm);					<span class="hljs-comment">//PWM_1_WriteCompare1((uint16)curr_pwm);</span>
	CY_SET_REG16(PWM_1_COMPARE2_LSB_PTR, (uint16)(PWM2DC(curr_pwm)));	<span class="hljs-comment">//PWM_1_WriteCompare2((uint16)((curr_pwm &gt;&gt; 1) + 1));	</span>
	<span class="hljs-comment">//Compare 2 can't be 0 or the ADC won't trigger =&gt; that's why I'm adding 1</span>
	
	<span class="hljs-keyword">return</span> ctrl.current.error;
}
</pre><p>To avoid destroying expensive Maxon motors during the calibration phase a test bench was designed and assembled. In the present configuration the phase to phase specs are 120µH and 0.4Ω. The power resistors are rated for 200W. The larger inductance makes it safer for the power electronics under test. The current ripple will be half of the Maxon's.</p><p><img src="https://cdn.hackaday.io/images/2840171433176331138.jpg"></p>The first test I did was static: set a current setpoint, measure the real current, plot. <p><img src="https://cdn.hackaday.io/images/7237111433176362891.png"></p><br><p>The sense resistor is 5mΩ, the analog gain is 20 and the ADC is 12bits over 5V. The theoretical current resolution is 12.2mA/bit. With a setpoint of 500, the expected current is 6.1A and the measured value is 5.94A. The absolute error is only 2.6% and the transfer function is extremely linear, great!<br></p><p>I had to make sure that the dynamics of my controller were fast enough to be used on robotic devices. To test that, I created an arbitrary waveform (a mix of triangles, sinusoids and square waves with abrupt transitions). I outputted the current controller setpoint on a DAC (yellow) and I measured the current flowing in one phase with a current probe (green). As you can see on the picture below, my current controller has no problem tracking the waveform.<br></p><p><img src="https://cdn.hackaday.io/images/8059171433176563464.jpg"></p><br></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/5765/log/18827-introduction-why-do-we-care">Introduction (why do we care?)</a></h2>
                            <small class="authorship">3 months ago  &bull;
                                <a class="gray-link" href="/project/5765/log/18827#discussion-list">
                                    0 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-18827"><p><em>Note: this is copied from my thesis, please refer to the full document for references and additional graphics.</em></p><p>"Reinventing the wheel" is an idiom often associated with engineering and design. While innovators use the expression to describe a ground breaking solution or design, it mostly has a negative connotation. Engineers will be told not to reinvent the wheel when they are struggling with details or technicalities rather than focusing on the big picture, the problem worth solving. But what if that metaphorical wheel was indeed broken? Looking back at previous work in the field of exoskeletons and powered prostheses can be depressing for an embedded system designer. The wheel, in the form of the embedded electronics, is redesigned year after year, project after project, with no clear progression and many system redesigns. The 'big picture' problem is to give mobility to people that lost it, to augment able-bodied people, not to design electronics, but it is a critical component that can, in the worst case situation, invalidate a revolutionary artificial limb concept.</p><p>This thesis is not about the design of a novel wearable robotic device that contains an embedded system; it's purely about the design of the embedded system itself. The objective of the thesis is to advance an accessible and capable embedded system architecture that is useable across all wearable robotic research initiatives, eliminating the need to design a new embedded system for each and every research project. Ironically enough, once more, the goal is to redesign the wheel, but hopefully for the last time. Through a careful analysis of wearable robotic requirements across sensor, actuator and computational modalities, I will demonstrate in this thesis that an embedded system design can be achieved that is scalable across a plethora of wearable robotic research programs, and therefore will be used henceforth for more than one year in one project.</p><p>There are two main ways of designing electronic architectures for active wearable robotics: 1) microcontroller-based and 2) embedded computer-based. Figure 1 shows a typical microcontroller-based architecture with a single 80MHz processor [1]. Figure 2 shows an architecture based on an embedded computer, a Raspberry Pi running at 800MHz [2]. Commercial products are mostly microcontroller-based while research prototypes tend to favor systems with embedded computers [2][11][17]. </p><table> <tbody><tr> <td> <p><b>Microcontroller</b></p> </td> <td> <p><b>Embedded Computer</b></p> </td> </tr> <tr> <td colspan="2"> <p><i>Pros</i></p> </td> </tr> <tr> <td> <ul><li>Small form factor that can easily be adapted to different mechanical designs</li> <li>Low power</li> <li>Unit cost is low</li> <li>Low level software (C and/or ASM): processor efficient</li> </ul></td> <td> <li>Quick design phase</li> <li>High-level software (C++, Python, Java, Matlab): ease of development</li> <li>Minimize the number of specialized skills required to modify the system</li> </td> </tr> <tr> <td colspan="2"> <p><i>Cons</i></p> </td> </tr> <tr> <td> <ul><li>Development (prototyping) cost can be higher</li> <li>Longer design phase</li> <li>Requires Electrical Engineering skills for the design, maintenance and modification</li> <li>Low level software (C and/or ASM): less portable, requires specialized skills</li> </ul></td> <td> <li>High-level software (C++, Python, Java, Matlab): not processor efficient</li> <li>Higher power (less energy efficient)</li> <li>Relies on commercial parts (no control over the production and life cycle)</li> <li>Harder to modify</li> <li>Integration issues between different subsystems</li> <li>Sub optimal wiring</li> </td> </tr></tbody></table><p>The two approaches have been used in a multitude of published wearable robotic systems, with various degrees of success. A few examples are described here [1][2][13][17]. Since the embedded system aspect of a design is considered a means to an end, documentation is considered unimportant and is usually scarce. Following the evolution of a wearable robotic design, one will read sentences such as "Developed a new embedded electronic system" without a clear justification as to why the previous design had to be abandoned rather than improved.</p><p>In all of the designs made in the MIT Biomechatronics Group over the last 11 years, <a name="OLE_LINK17"></a>only one project (AAKP, Agonist-Antagonist Active Knee Prosthesis [18]) used two actuators in one joint. Due to issues with the control electronics of previous prototypes, brushed DC motors (in lieu of brushless DC motors) were used, thus impacting the efficiency and mass of the prosthesis. When experiments were conducted with trans-femoral amputees wearing an active ankle-foot and an active knee the two joints were controlled independently, without an overarching high-level controller. Consequently, the lack of availability of an appropriate embedded system solution had a direct impact on the system design and performance [2][11].</p><p>After reading papers, grant reports and interviewing wearable robotic designers, the following list of general system problems and reasons justifying new designs was compiled:</p> <ul><li>Lack of reliability</li> <li>Lack of processing power, overloaded microcontroller</li> <li>The original designer left the laboratory</li> <li>No electrical engineer on the team</li> <li>Slow communication peripherals</li> <li>Can only support brushed motors</li> <li>Can only support one motor</li> <li>Commercial motor driver has to be tricked into running a special control loop, no built in functionality</li> <li>Power consumption</li> <li>Size, mechanical integration issues</li></ul> <p>These problems are shared by many researchers in related fields such as humanoid robotics and wearable computers, therefore many designers and companies have attempted to design a unified embedded system that could be used in a broad range of projects. Commercially available modular hardware platforms include the Microsoft .NET Gadgeteer system, "an open-source toolkit for building small electronic devices using the .NET Micro Framework"[1] [3], the popular Arduino and its Shields ("Shields are boards that can be plugged on top of the Arduino PCB extending its capabilities."[2]), the BeagleBone Black embedded computer with the Capes and the Intel Edison with the Blocks[3]. SparkFun popularized the use of "breakout boards", minimalist circuit boards that simply prototyping. These products are now commonly integrated in academic research projects [2][3][9][11]. Custom embedded system designs have been published for wireless sensing [5], miniature mobile robots [6], and mechatronics education and teaching [7][8]. The common goals are to minimize the number of circuit redesigns and simplify prototyping [5]. </p><p>The price to pay for modularity is often the increase of the number of circuit boards required for an application, and the increase of inter-board connections. Wearable robotics projects have different requirements than most pure robotics and wearable sensing projects. Safety and reliability are major issues, especially in powered prosthetic devices. Simplifying the devices by using a minimal number of circuit boards and by minimizing the number of interconnections helps with safety and reliability. The number of degrees of freedom is relatively small (compared to humanoid robotics), but the instantaneous power requirements are high [2][19]; a greater emphasis has to be placed on power electronics than on digital communication between the modules. The volume and the weight of the embedded system must be minimized because of their direct impact on the efficiency of devices attached to body extremities [19]. </p><p>This thesis presents the design of a modular embedded system optimized for wearable robotic applications. A flexible architecture allows FlexSEA to be used in a wide variety of projects, with or without an embedded computer. All the safety features of commercial devices are included onboard, as well as all the typical sensors and output device interfaces required for wearable robotic applications. The highly integrated circuit board designs presented in the thesis minimize the weight of the embedded system, require a minimal amount of wired connections, and are proven to be easy to use by students. The design was evaluated by a user test and by multiple quantifiable metrics related to the electrical performance of the different circuit board, and of the system as a whole.</p></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/5765/log/18828-design-solutions-short-answers">Design solutions – short answers</a></h2>
                            <small class="authorship">3 months ago  &bull;
                                <a class="gray-link" href="/project/5765/log/18828#discussion-list">
                                    0 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-18828"><p>While all the details are available in the thesis, this section offers quick answers and solutions to all the issues identified in the introduction.</p><p><b>Lack of reliability:</b> The issue of reliability is addressed at the board level with good design practice, documented unit tests and the use of safety mechanisms (such as ESD protected inputs). At the system level, the number of connections is reduced by embedding more features in the boards, and robust yet miniature connectors are used.</p><p><b>Lack of processing power, overloaded microcontroller:</b> A dedicated microcontroller with a wide array of sensor inputs on the motor controller (FlexSEA-Execute) offloads the other computing units (FlexSEA-Mange and FlexSEA-Plan) from the intensive motor control functions. The microcontrollers used are also high performance. The optional embedded computer can be used for processor intensive applications.</p><p><b>"The original designer left" &amp; "No electrical engineer in the team":</b> Documentation must be exhaustive and accurate in order to fully enable the user. One of the graduation criteria is a user test. The system is designed in a modular way; the least intrusive way of using FlexSEA is to use a simple Linux terminal.</p><p><b>Slow communication peripherals:</b> Closing control loops requires deterministic timings and fast refresh rates; it places a lot of stress on the board-to-board communication interfaces. By closing the critical control loops on FlexSEA-Execute we offload the communication interfaces. The FlexSEA-Manage board is also used as a bridge, communicating with FlexSEA-Plan via a high-speed SPI interface and communicating with other boards and peripherals via a variety of other communication protocols.</p><p><b>Can only support brushed motors:</b> The Execute board is designed for brushless motors; it can inherently support brushed motors.</p><p><b>Can only support one motor:</b> FlexSEA has been designed with scalability in mind. With its two serial interfaces, FlexSEA-Manage can support two FlexSEA-Execute without any bandwidth restrictions. More than one FlexSEA-Execute can be on each bus, the total bandwidth being divided between the boards.</p><p><b>Commercial motor driver has to be tricked into running a special control loop, no built in functionality:</b> The user has full control over the hardware and the software of the motor driver. Any type of controller can be programmed in C and can run at high speed on the Execute board. The Expansion connector supports a wide variety of external sensors; they can all be used in control loops.</p><p><b>Power consumption:</b> The power consumption of the embedded system can be high when an embedded computer is used. Better energy efficiency can be obtained by using a simpler computer; HD video peripherals, audio amplifiers and wired Ethernet connections are not required in wearable robotics applications. By maximizing the use of FlexSEA-Execute and FlexSEA-Manage, the FlexSEA-Plan computing requirements are lowered. A slower device can be used, or it can be placed in sleep mode between actions. Eliminating FlexSEA-Plan and programming the high-level algorithms on FlexSEA-Manage or FlexSEA-Execute can be extremely energy efficient.</p><p><b>Size, mechanical integration:</b> The Execute and Manage boards were designed to be as small and light as possible. They have an integration level comparable to commercial products while having accessible connectors for inputs and outputs.</p></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/5765/log/22622-whats-new-code-files-videos">What&#39;s new? Code, files &amp; videos!</a></h2>
                            <small class="authorship">5 days ago  &bull;
                                <a class="gray-link" href="/project/5765/log/22622#discussion-list">
                                    0 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-22622"><p>Hello Makers!</p><p>With the Quarter Finals deadline coming it&apos;s time for a project update. I published most of the available information last May and June, just before graduating. I then left for a long bicycle camping trip; that&apos;s why nothing changed. Now that I&apos;m back, I&apos;m working full time as a Research Scientist in Biomechatronics and pushing FlexSEA further is one on my main projects. In the coming months I&apos;ll publish way more information about the system, including exoskeleton videos. Stay tuned! In the mean time, here&apos;s some new info:</p><ol><li><a href="https://youtu.be/ECVeH0Szszc" target="_blank">Introduction video</a></li><li>You can now get a copy of the <a href="https://www.dropbox.com/s/3nthb66xkaz167s/flexsea_1_0.7z?dl=0" target="_blank">software projects</a> and the <a href="https://www.dropbox.com/s/lzi0a950flr94j0/FlexSEA_0_1_062015.7z?dl=0" target="_blank">hardware design files</a>.</li><li>In terms of system design document, please refer to my <a href="http://jfduval.ca/flexsea/JFDuval_Thesis_FlexSEA_Final.pdf" target="_blank">thesis</a>. It contains extensive details about the hardware and the software. It&apos;s a great snapshot of the design as of May 2015.</li><li>As far as licensing goes, the thesis is licensed under Creative Common Attribution-NonCommercial-ShareAlike (CC BY-NC-SA 2015) and the hardware files are Open Source Hardware.</li><li>During my absence my colleague Luke Mooney used FlexSEA-Execute for his exoskeleton. Here&apos;s a <a href="https://www.youtube.com/watch?v=omGtC379Oa0&amp;feature=youtu.be" target="_blank">short video of when he tested his force controller</a>, using a strain gauge and the built-in amplifier of Execute 0.1<a href="https://www.youtube.com/watch?v=omGtC379Oa0&amp;feature=youtu.be.">.</a></li><li>Do not hesitate to ask me questions about the system in the comments below!</li><li>I&apos;m looking for contributors for the project. Drop me a line if you are interested.</li></ol><p><br><img src="https://cdn.hackaday.io/images/7353971439408543162.jpg"></p></div>
                            </div>
                        </li>
                    
                </ul>

                

                

                </p>

            
        </div>
    </div>

    










<div class="footer" id="footer">
  <a href="#header" class="back-to-top" onClick="CT(this, 'Footer', 'GoingUp');">^ Going up? ^</a>
    <div class="container">
        <p><a href="http://hackaday.com/about/">About Us</a> <a href="mailto:projects-contact@hackaday.com">Contact Us</a> <a href="/project/37">Give Feedback</a>&copy; 2015 Hackaday <a href="/tos">Terms of Use</a> <a href="/privacy-policy">Privacy Policy</a></p>
        <a href="/" class="had-skull"  onClick="CT(this, 'Footer', 'Home' ); return false;">Hackaday.io</a>
    </div>
</div>

<script>

    var csrftoken = '07hhDJEM-ZBQQ_yqA9g9tnSu_25ygrIONeeA';

</script>

    <script type="text/javascript">

    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-47229708-1', 'auto');

    var dimensionValue = 'nonregistered';
    ga('set', 'dimension1', dimensionValue);
    ga('require', 'displayfeatures');

    ga('send', 'pageview');

    </script>

<img src="//analytics.supplyframe.com/trackingservlet/impression?action=pageImpression&amp;zone=HIO_logs&amp;extra=logged%3Dfalse%7ChaveAccountCookie%3D0%7C&amp;ab=undefined" class="sf-impression" />

    
    
    <script src="//cdn.hackaday.io/build/h%2FydgsYIeDTf7pqgYQEKK8Ngblw0IkZCDqfJ9S2tk7zsBoxIHt5iOd49Qp%2BF4vdxEuRj%2BGpGDLbX4aGOQGmbjaOxUZvklg4ReFk68R95OQshFrGKebvogKGQOiB5Hi1xym9KC54c9Ps0WpzuNydLk4B%2FbKi91KhV40Uxhl38XXb1IVAxAI8iW%2BoQUPCFkHVWZxD0B%2BMZ%2BuEXJTlWuBmopNMxTHRK5yleITPZODT6evbVRQc6AXs9w2Pfk7FS2nKy-0.48.6.js"></script>

</body>
</html>