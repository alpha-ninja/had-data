<!doctype html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if IE 9]>    <html class="no-js ie9" lang="en"> <![endif]-->
<!--[if gt IE 9]><!--> <html class="no-js" lang="en" ng-app="buildlogApp"> <!--<![endif]-->
<head>
    
    <title>Project logs &bull; Neurons, neurons, neurons... &bull; Hackaday.io</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="//cdn.hackaday.io/css/style.css?version=0.48.6" />
    <script type="text/javascript" src="//use.typekit.net/ymb0lgk.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
</head>
<body class="logs">

    <!--
############################################################################################
############################################################################################
############################################################################################
#####################Kt;tL#######################################Kti,E######################
#######################;   .###################################G    E#######################
#######################K    f##################################    ;########################
########################Wj   E###############################K:  .W#########################
##########################.  :E##############################:  .L##########################
#########################D    f##############################.   .##########################
########################,     ;##############################     :E#######K################
################f######K      ,##############################      ,######Lt################
################  W###W       i##############################       t####j t################
################:  E#L.        f###########################L.        f#Ki .E################
################j  ;E.          j##########################.         .G;  i#################
#################L               i#######################K                ##################
#################W                E#####################K;               ;##################
###################:               .###################D               :f###################
#####################DLfGD           G####WEEEEKW####W           ;GffGK#####################
##########################i         iD##Kfi    :jKW##D          iE##########################
###########################W      ,G##f            jE#E;       j############################
############################L     D##D              ,##K       W############################
#############################D:  G#W                  K#E,   G##############################
###############################;i#L                    j## ,E###############################
###############################KK#.                     ##iE################################
#################################j                      ;K##################################
################################W                        ,##################################
################################E                         ##################################
###############################Ki                         D#################################
###############################E.                         L#################################
###############################f    iD##W;       D###D    :#################################
###############################i   i######K     K#####K;   #################################
###############################;  .E#######     #######D   #################################
###############################;  L########     ########   #################################
###############################i  G#######K     K#######   #################################
###############################j  L#####E,       fE#####   #################################
###############################D  .E##j            .t##E  ;#################################
###############################E:  ;##.              #Wt  j#################################
################################G   ;t      tWi      t    E#################################
#############################KL##           K#K;          #K:K##############################
#############################i ##:          ###t         j#f ;K#############################
############################:  G#K          #E#L        L##    D############################
###########################D   ;W#:         #;#L        W#K    .############################
#####################KKEKK      :##L        ; ..      :D##.      fKEEK######################
###################t.            ;##G:               ,##E,             tD###################
##################G               E##E               i##;               :###################
#################D                W##W    iL    E.    ###D                ##################
################W,               G###W    tG    K.    ####:               K#################
################;  LW;         ,E#####:  ;W#    #G   f#####;         ;KG  :K################
################  D###E       ;########WW####WW####WW#######W       :####: j################
################ ,#####:      ;##############################       G####E i################
################K#######.     ;##############################      L######WG################
########################f     i##############################     j#########################
#########################W   .D##############################.   i##########################
#########################E   G###############################D   ,##########################
########################G:   #################################j   G#########################
#######################f    K##################################j    W#######################
#####################Kt :iE#####################################KL:  K######################
############################################################################################
############################################################################################
############################################################################################
-->

<div class="header" id="header">
    <div class="container">
        <h1 class="logo">
            <a href="/" title="Hackaday.io Home" class="home" onclick="CT(this, 'Menu', 'Home'); return false;"></a>
            <a href="/" title="Hackaday.io Home" class="brand" onclick="CT(this, 'Menu', 'Home'); return false;">Hack a Day</a>
        </h1>

        <a href="javascript:void(0);" class="responsive-menu">Menu</a>

        <ul class="nav" role="navigation">
            <li><a href="/projects" class="">Projects</a></li>
            <li><a href="/lists" class="">Lists</a></li>
            <li><a href="/stack" class="">Stack</a></li>
            <li class="dropdown more-nav j-more-open">
                <a href="javascript:void(0)" class="dropdown-link icon-dropdown">More</a>
                <ul role="menu" class="dropdown-menu more-menu" id="j-more">
                    <li><a href="http://hackaday.com/blog/" target="_blank">Blog</a></li>
                    <li><a href="/events">Events</a></li>
                    <li><a href="/hackerspaces">Hackerspaces</a></li>
                    <li><a href="/hackers">Profiles</a></li>
                    <li><a href="/contests">Contests</a></li>
                    <li><a href="/prize" target="_blank">The Hackaday Prize</a></li>
                    <li><a href="/submissions/prize2015/list">2015 Prize Entries</a></li>
                </ul>
            </li>
            <li class="menu-last-child">
                <div class="search-holder show">
                    <form id="search-form" action="/search" onsubmit="return submitSearch();" method="GET">
                        <input type="text" placeholder="Search" name="term" class="input-search j-add-search" id="j-add-search" value="" autocomplete="off" pattern=".{3,}" required title="3 characters minimum" />
                        <input type="submit" class="search-button" />
                    </form>
                </div>
            </li>
        </ul>

        

            <ul class="nav pull-right" role="navigation">
                <li><a href="/signup" class="grey-white-button become-member">Sign up</a></li>
                <li><a href="/signin?returnUrl=%2Fproject%2F3339%2Flogs%3Fpage%3D2">Sign in</a></li>
            </ul>

        
    </div>
</div>

<div id="topMessage" class="alert"><span class="j-top-content"></span><a href="javascript:void(0);" class="alert-close j-top-message-close">Close</a></div>




    <div class="headline">
        <div class="container">
            <h2><a href="/project/3339-neurons-neurons-neurons">Neurons, neurons, neurons...</a></h2>
            <p class="description-title"> Project logs</p>
            <p class="description-summary">Hardware neuron simulation and learning system</p>
            <div class="description-metainfo">
                
                    <span>created by <a href="/hacker/7100-zakqwy" title="Visit Profile">zakqwy</a><span>&bull;</span>
                
                9 months ago<span>&bull;</span><a href="/project/3339#discussion-list" title="See Comments">16 Comments</a></span>
            </div>
        </div>
    </div>

    <div class="container post-content">
        <div class="section-buildsort">
            <span class="pull-left">
                <a href="/project/3339-neurons-neurons-neurons">&#171; Back to project details</a>
            </span>
            <span class="sort-holder pull-right">
                <label for="sort-by">Sort by:</label>
                <select class="sort" id="sort-by">
                    <option value="/project/3339/logs/sort/newest">Newest</option>
                    <option value="/project/3339/logs/sort/oldest" selected="selected">Oldest</option>
                </select>
            </span>
        </div>
        <div class="section section-buildlogs last">
            

                <ul class="buillogs-list">
                    
                        <li>
                            <h2><a href="/project/3339/log/11684-neuron-development-v04-part-6-mass-production">Neuron Development: v0.4 part 6: Mass Production</a></h2>
                            <small class="authorship">8 months ago  &bull;
                                <a class="gray-link" href="/project/3339/log/11684#discussion-list">
                                    2 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-11684"><p>Neuron production has begun. This is my first foray into reflow work, so there has been a bit of a learning curve. Here, I made two sticks of four Neurons each and uploaded a test program to light the LEDs up white:</p><p><img src="https://cdn.hackaday.io/images/5554321417995659396.jpg"></p><p>Next, I tried doing eight at a time:</p><p><img src="https://cdn.hackaday.io/images/4615741417995706638.jpg"></p><p>Many observations:</p><ul><li>Solder mask is <em>amazing</em>. I'm hand-applying solder paste from a syringe, giving me inconsistent and sloppy results prior to placing components--90% of the time, it doesn't matter. Bridges seem to magically fix themselves in the oven.</li><li>I should have sprung for a stencil. Seriously, hand-applying solder paste is tedious and frustrating.</li><li>The oven is decent, but not great. Some of my Neuron boards have gotten a bit discolored from the heat while I reset the cycle to ensure other sections fully reflow; the lack of convection fan means temperature stratification is pretty severe. It works, but requires a close eye and a hand on the 'add time' button. </li><li>Hand soldering the connectors takes time but isn't too unpleasant. The headers friction fit nicely into the board so I don't need to bend leads to hold 'em in. After soldering I generally clip the leads as close to flush as possible--probably a bit more than I should for maximum structural integrity, but I don't want the bottom of the boards to be too sharp.</li><li>I've made a lot of Neurons at this point--probably 70+, although some of them are with Andrew in NYC and another batch are with a different friend for some testing. I haven't kept great production records, but generally speaking I'm running around 85% first-round yield, with another 5-10% recoverable using hand rework (generally to fix one of the LED pads not quite connecting right). The units that never work are usually the result of a stupid error (I installed a number of ATTinys backwards) or a huge amount of excess solder gumming everything up.</li></ul><p><img src="https://cdn.hackaday.io/images/6170001417996523038.JPG"></p><p><img src="https://cdn.hackaday.io/images/4980741417997567689.JPG"></p><p>Up next: firmware!<br></p></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/3339/log/11853-neuron-development-v04-part-7-firmware">Neuron Development: v0.4 part 7: Firmware</a></h2>
                            <small class="authorship">8 months ago  &bull;
                                <a class="gray-link" href="/project/3339/log/11853#discussion-list">
                                    5 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-11853"><p>This is important: Zach will never be a skilled programmer. I can bang out half-functional (albeit inefficient and buggy) code when I need to, but it usually involves a lot of cursing and frivolous Google searches. This being my first foray into AVR-C is no exception, so bear with me. Constructive criticism is encouraged.</p><p>A few weeks ago I discussed Neuron v04's <a href="http://hackaday.io/project/3339/log/11386">circuit design and board layout</a>; when I added that project log, I also added a link to the <a href="https://github.com/zakqwy/Neuron">Neuron Github repo</a> which includes both hardware AND software stuff. I've been really bad with revision control for this project, so with any luck publishing the repo will force me to use good practices when updating the firmware. Seriously--the code is pretty much identical to the contents of a folder called 'v04test7' that was buried in a series of Dropbox directories; I only chose it because the mysteriously named 'v04test8' and 'v04test9' had some undocumented bug that I couldn't figure out. </p><p>Originally I tried posting the code as-is using the 'code snippet' function, but that doesn't seem to respect tabs (at least in this Ubuntu 14/Firefox 33 combo) which made it pretty hard to understand. As such, I'm going to go through the <a href="https://github.com/zakqwy/Neuron/blob/master/FIRMWARE/v04run/main.c">main runtime firmware</a> here in its entirety, replacing the inline comments with a more in-depth discussion where it seems to make sense. Note that &lt;code&gt; precedes //comments in sections with multiple snippets.</p><hr><p><strong></strong><strong></strong><strong>Licensing</strong></p><pre class="hljs cs">/*
Copywrite <span class="hljs-number">2014</span>, Zach Fredin
zachary.fredin<span class="hljs-decorator">@gmail.com</span>

This file <span class="hljs-keyword">is</span> part of Neuron.
Neuron <span class="hljs-keyword">is</span> free software: you can redistribute it <span class="hljs-keyword">and</span>/<span class="hljs-keyword">or</span> modify
it under the terms of the GNU General Public License <span class="hljs-keyword">as</span> published by
the Free Software Foundation, either version <span class="hljs-number">3</span> of the License, <span class="hljs-keyword">or</span>
(at your option) any later version.
Neuron <span class="hljs-keyword">is</span> distributed <span class="hljs-keyword">in</span> the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY <span class="hljs-keyword">or</span> FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License <span class="hljs-keyword">for</span> more details.
You should have received a copy of the GNU General Public License
along <span class="hljs-keyword">with</span> Neuron. If <span class="hljs-keyword">not</span>, see &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;.
*/</pre>GNU GPL v3 blah blah blah<hr><p><strong></strong><strong></strong><strong></strong><strong></strong><strong></strong><strong></strong><strong>Libraries</strong></p><pre class="hljs cpp"><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;avr/io.h&gt;</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;avr/interrupt.h&gt;</span></pre>Pretty basic. We need to send signals to the chip through its I/O lines, and we interrupts to work for the inputs.<hr>
<p><strong>Variables</strong></p><pre class="hljs cpp"><span class="hljs-title">int16_t</span> ledGreenfade = <span class="hljs-number">1</span>;
<span class="hljs-title">int16_t</span> ledRedfade = <span class="hljs-number">0</span>;
<span class="hljs-title">int16_t</span> ledBluefade = <span class="hljs-number">0</span>;</pre>LED brightness variables, scaled from 0 (dimmest) to 100 (brightest). I don't quite recall why I made these 16-bits; probably to fix a pesky error. Also, the green LED is initially set on (but very dim) which isn't too relevant, since these values will be overwritten as soon as the main program starts.<pre class="hljs cpp">uint8_t debounceValue = <span class="hljs-number">5</span>;
uint8_t exDebounceCount1 = <span class="hljs-number">0</span>;<span class="hljs-regexp">//excitatory</span> <span class="hljs-number">1</span>, which is <span class="hljs-constant">K1</span>, pin <span class="hljs-number">8</span>, <span class="hljs-constant">PA5</span>, <span class="hljs-keyword">and</span> <span class="hljs-constant">PCINT5</span>.
uint8_t exDebounceCount2 = <span class="hljs-number">0</span>;<span class="hljs-regexp">//excitatory</span> <span class="hljs-number">2</span>, which is <span class="hljs-constant">K3</span>, pin <span class="hljs-number">10</span>, <span class="hljs-constant">PA3</span>, <span class="hljs-keyword">and</span> <span class="hljs-constant">PCINT3</span>.
uint8_t exDebounceCount3 = <span class="hljs-number">0</span>;<span class="hljs-regexp">//excitatory</span> <span class="hljs-number">3</span>, which is <span class="hljs-constant">K5</span>, pin <span class="hljs-number">12</span>, <span class="hljs-constant">PA1</span>, <span class="hljs-keyword">and</span> <span class="hljs-constant">PCINT1</span>.
uint8_t exDebounceCount4 = <span class="hljs-number">0</span>;<span class="hljs-regexp">//excitatory</span> <span class="hljs-number">4</span>, which is <span class="hljs-constant">K6</span>, pin <span class="hljs-number">13</span>, <span class="hljs-constant">PA0</span>, <span class="hljs-keyword">and</span> <span class="hljs-constant">PCINT0</span>.
uint8_t exDebounceCount5 = <span class="hljs-number">0</span>;<span class="hljs-regexp">//excitatory</span> <span class="hljs-number">5</span>, which is <span class="hljs-constant">K2</span>, pin <span class="hljs-number">9</span>, <span class="hljs-constant">PA4</span>, <span class="hljs-keyword">and</span> <span class="hljs-constant">PCINT4</span>.
uint8_t inDebounceCount1 = <span class="hljs-number">0</span>;<span class="hljs-regexp">//inhibitory</span> <span class="hljs-number">2</span>, which is <span class="hljs-constant">K4</span>, pin <span class="hljs-number">11</span>, <span class="hljs-constant">PA2</span>, <span class="hljs-keyword">and</span> <span class="hljs-constant">PCINT2</span>.</pre>Debounce counter limit and individual debounce variables for each of the six inputs; I wanted to keep these separate since I didn't want to invalidate quickly occurring pulses on two <em>different</em> inputs (just a single input). Time units are in ms. Yeah, this could probably be an array.
<pre class="hljs cpp"><span class="hljs-title">int16_t</span> potentialTotal = <span class="hljs-number">0</span>;
<span class="hljs-title">int16_t</span> inGroundState = <span class="hljs-number">0</span>;
<span class="hljs-title">int16_t</span> inGroundStatePrevious = <span class="hljs-number">0</span>;
<span class="hljs-title">int16_t</span> exGroundState = <span class="hljs-number">0</span>;
<span class="hljs-title">int16_t</span> exGroundStatePrevious = <span class="hljs-number">0</span>;
<span class="hljs-title">int16_t</span> decayPotential = <span class="hljs-number">0</span>;
</pre>These keep track of the current membrane potential of the Neuron. I track the excitatory and inhibitory portions of this value along with a decay multiplier separately, along with previous values for inhibitory and excitatory potential.<pre class="hljs cpp"><span class="hljs-title">uint8_t</span> potentialTimerOverflow = <span class="hljs-number">5</span>;
<span class="hljs-title">uint8_t</span> potentialTimerCounter = <span class="hljs-number">0</span>;</pre><p>Uh.. to be commented later.<br></p><pre class="hljs cpp">uint16_t timer1Overflow = <span class="hljs-number">10</span>;<span class="hljs-comment">//FAST loop overflow</span>
uint16_t timer2Overflow = <span class="hljs-number">800</span>;<span class="hljs-comment">//SLOW loop overflow</span>
uint16_t timer2Counter = <span class="hljs-number">0</span>;</pre>Timer variables. timer2 is nested within timer1, and timer1 is tied with the system clock. Since I'm running these (currently) at 8 MHz, timer1 should click over at 800 kHz and timer2 should run at 1 kHz. My 'scope seems to confirm that, although I should probably check again at some point. AVR timers are confusing.<pre class="hljs cpp">uint8_t inputMagnitude = <span class="hljs-number">70</span>;<span class="hljs-comment">//amount each input increases/decreases potential</span>
uint8_t inputStatus = <span class="hljs-number">0</span>b00000000;<span class="hljs-comment">//current input status (read when stuff changes!)</span></pre>inputMagnitude, as commented, shows how much each excitatory or inhibitory pulse changes the current membrane potential of the Neuron (with +100 assumed to be the action potential threshold). inputStatus--I like to write out bytes when each bit refers to something because it's easy to quickly understand. I suppose that isn't a great way to learn hex. In this case, I'm setting the inputs low for initialization. 
<pre class="hljs cpp">uint8_t fireTimerOverflow = <span class="hljs-number">2</span>;<span class="hljs-comment">//how long should LED pulses last?</span>
uint8_t fireTimerCounter = <span class="hljs-number">2</span>;
uint8_t fireDelayOverflow = <span class="hljs-number">20</span>;<span class="hljs-comment">//after firing, how long until sending a pulse?</span>
uint8_t fireDelayCounter = <span class="hljs-number">0</span>;</pre>These variables deal with action potential events and are timed in milliseconds (they're part of the timer2 loop). 'Firing' means flashing all LEDs at once at full brightness, and the delay shows how long to wait until sending a pulse down the axon. I'm not sure that's working quite right, because I'm pretty sure my Neurons aren't updating at 50 Hz. Hmmm...<hr><p><strong>Interrupt Service Routine</strong></p><pre class="hljs cpp">ISR(PCINT0_vect) { <span class="hljs-comment">//interrupt svc routine called when PCINT0 changes state</span>
<span class="hljs-comment">//note that this is different than the ATtiny45 version</span>
inputStatus = PINA;
}</pre>Any time stuff changes on the input pins (they're covered by PCINT0_vect), I read their current values into the inputStatus variable and return to the current position in the program. Yay interrupts!<hr><p><strong>LED update function</strong></p><pre class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateLEDs</span><span class="hljs-params">(uint16_t Counter, uint16_t Red, uint16_t Green, uint16_t Blue)</span> </span>{
<span class="hljs-keyword">if</span> (Counter &gt;= Green){
PORTB |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<span class="hljs-comment">//wahoo, bitwise logic! turns</span>
<span class="hljs-comment">//the green LED on (low)</span>
<span class="hljs-comment">//for the first part of the</span>
<span class="hljs-comment">//PWM waveform</span>
}
<span class="hljs-keyword">else</span> {
PORTB &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">0</span>);<span class="hljs-comment">//more bitwise logic. turns</span>
<span class="hljs-comment">//the green LED off (high)</span>
<span class="hljs-comment">//for the second part of the</span>
<span class="hljs-comment">//PWM waveform.</span>
}
<span class="hljs-keyword">if</span> (Counter &gt;= Red){
PORTB |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);<span class="hljs-comment">//see above. this could</span>
<span class="hljs-comment">//probably be simplified into</span>
<span class="hljs-comment">//a swanky function of some</span>
<span class="hljs-comment">//type.</span>
}
<span class="hljs-keyword">else</span> {
PORTB &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span>);
}
<span class="hljs-keyword">if</span> (Counter &gt;= Blue){
PORTB |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>);
}
<span class="hljs-keyword">else</span> {
PORTB &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>);
}
}
</pre>So... I needed to run my main program code pretty fast, but I also wanted PWM fading on each LED channel. Also, Neuron color fading isn't really linear across the full range of membrane potential; when the value is below zero the LED fades from green towards blue, and when above zero it fades from green towards red. This function is intended to be called during the fast loop--the first argument (Counter) says where you are in the PWM waveform, while the next three arguments (Red, Green, Blue) says how long each color should be high for each part of that waveform. Everything else is unnecessary comments, unoptimized code, and flipping bits on PORTB (where the LEDs are the three least significant bits). <hr><p><strong>System Initialization </strong></p><pre class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SystemInit</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
DDRA = <span class="hljs-number">0</span>b01000000; <span class="hljs-comment">//IO config: PA0-5 in (dendrites), PA6 out (axon)</span>
PORTA = <span class="hljs-number">0</span>b00000000; <span class="hljs-comment">//Turns off pull-up resistors on dendrites, sets axon low</span>
DDRB = <span class="hljs-number">0</span>b00000111; <span class="hljs-comment">//IO config: PB0,1,2 out (LEDs), all others in</span>
PORTB = <span class="hljs-number">0</span>b00000111; <span class="hljs-comment">//Sets PB0,1,2 high to start (LEDs off).</span>
TCCR1B = <span class="hljs-number">0</span>b00000001; <span class="hljs-comment">// sets up a timer at 1MHz (or base AVR speed)</span>
sei(); <span class="hljs-comment">//enable all interrupts: same as changing bit 7 of SREG to 1</span>
GIMSK |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>);<span class="hljs-comment">//sets the general input mask register's 4th bit to 1</span>
<span class="hljs-comment">//to activate the PCIE0 interrupt stuff</span>
PCMSK0 = <span class="hljs-number">0</span>b00111111; <span class="hljs-comment">//sets the six dendrites to active hardware interrupts (0-5)</span>
inputStatus = PINA;
exDebounceCount1 = debounceValue;
exDebounceCount2 = debounceValue;
exDebounceCount3 = debounceValue;
exDebounceCount4 = debounceValue;
exDebounceCount5 = debounceValue;
inDebounceCount1 = debounceValue;
</pre><p>The comments are pretty reasonable here. DDRA/PORTA are header connectors (second most significant bit is the axon), while DDRB/PORTB are the LEDs (well, at least the three least significant bits). OH YEAH, and the LEDS are wired with a common positive terminal, so pushing those bits HIGH turns them OFF. sei(), GIMSK, and PCMSK0, if I remember the datasheet correctly (doubtful), get interrupts working. The debounce variables probably could be set elsewhere but here they shall remain for now.</p><hr><p><strong>Main Program: Slow Loop</strong></p><pre class="hljs cpp"><span class="hljs-prompt">if (timer2Counter &gt;</span>= timer2Overflow) {

}</pre><p>I'm covering the main program in sections, starting from the inside out. The timer2 loop runs at 1 kHz.</p><pre class="hljs cpp"><span class="hljs-title">exGroundStatePrevious</span> = exGroundState;
<span class="hljs-title">exGroundState</span> = <span class="hljs-number">0</span>;
<span class="hljs-title">if</span> (((inputStatus &amp; 0b00100000) &gt; <span class="hljs-number">0</span>) &amp; (exDebounceCount1 == debounceValue)) {
<span class="hljs-title">exGroundState</span> += inputMagnitude;
}
<span class="hljs-title">if</span> (((inputStatus &amp; 0b00001000) &gt; <span class="hljs-number">0</span>) &amp; (exDebounceCount2 == debounceValue)) {
<span class="hljs-title">exGroundState</span> += inputMagnitude;
}
<span class="hljs-title">if</span> (((inputStatus &amp; 0b00000010) &gt; <span class="hljs-number">0</span>) &amp; (exDebounceCount3 == debounceValue)) {
<span class="hljs-title">exGroundState</span> += inputMagnitude;
}
<span class="hljs-title">if</span> (((inputStatus &amp; 0b00000001) &gt; <span class="hljs-number">0</span>) &amp; (exDebounceCount4 == debounceValue)) {
<span class="hljs-title">exGroundState</span> += inputMagnitude;
}
<span class="hljs-title">if</span> (((inputStatus &amp; 0b00010000) &gt; <span class="hljs-number">0</span>) &amp; (exDebounceCount5 == debounceValue)) {
<span class="hljs-title">exGroundState</span> += inputMagnitude;
}
<span class="hljs-title">inGroundStatePrevious</span> = inGroundState;
<span class="hljs-title">inGroundState</span> = <span class="hljs-number">0</span>;
<span class="hljs-title">if</span> (((inputStatus &amp; 0b00000100) &gt; <span class="hljs-number">0</span>) &amp; (inDebounceCount1 == debounceValue)) {
<span class="hljs-title">inGroundState</span> -= inputMagnitude;
}</pre><p>This is going to sound horrible, but sometimes I like writing repetitive code. As in, man... I just figured something out and I need to do it six times, time to copy-paste and change a few characters! Makes it look like I got a lot done <em>[shudder]</em>. </p><p>I start by storing the current excitatory or inhibitory membrane potential value in the appropriate 'previous' variable. Remember--I know what inputStatus is, I get it as soon as anything changes via the interrupt service routine. Each of those IF statements just masks that value against a few bytes (again, spelled out so I understand 'em) to see when various inputs are high. If they're high, and their debounce counters are full, I modify the appropriate variable based on the inputMagnitude value.</p><p>Oh man, I just remembered why I did it this way, and why they're called 'ground state'. This is the logic that allows me to use Exciters--you know, the shorting jumpers that allow me to <em>hold</em> a N<em></em>euron at a given potential value. Essentially, I can 'sensitize' Neurons using an Exciter so their new ground state is 70 instead of 0, meaning they'll hit an action potential with a single excitatory pulse. Okay, I should probably revise this post down the road to make it more clear--if you're reading this, I apologize for not understanding my own code and documentation.</p><p>Also just realized that I never reset the debounce counters, so... uh... they always stay full. Hmm, I guess they aren't as necessary as I thought they might be? Next section!</p><pre class="hljs cpp"><span class="hljs-keyword">if</span> (exGroundState &lt; exGroundStatePrevious) {
decayPotential += exGroundStatePrevious - exGroundState;
}
<span class="hljs-comment"></span><span class="hljs-keyword">if</span> (inGroundState &gt; inGroundStatePrevious) {
decayPotential -= inGroundState - inGroundStatePrevious; </pre>Looks to see if excitatory or inhibitory inputs have been REMOVED--as in, exGroundState gets SMALLER or inGroundState gets BIGGER. If either happens, we toss the difference into the decayPotential variable so it can start fading.
<pre class="hljs cpp"><span class="hljs-prompt">if (potentialTimerCounter &gt;</span>= potentialTimerOverflow) {
decayPotential = (decayPotential * <span class="hljs-number">95</span>) / <span class="hljs-number">100</span>;
}</pre>Fading using integer math to multiply by 0.95 every clock cycle. Pretty basic; once it gets low enough it rounds to 0. I think? Hmm, now the spreadsheet is telling me that it might stop at 10. I should look in to that, I suppose. It seems to be working in hardware.<pre class="hljs cpp"><span class="hljs-keyword">if</span> (exDebounceCount1 &lt; debounceValue) {
exDebounceCount1++;
}
<span class="hljs-keyword">if</span> (exDebounceCount2 &lt; debounceValue) {
exDebounceCount2++;
}
<span class="hljs-keyword">if</span> (exDebounceCount3 &lt; debounceValue) {
exDebounceCount3++;
}
<span class="hljs-keyword">if</span> (exDebounceCount4 &lt; debounceValue) {
exDebounceCount4++;
}
<span class="hljs-keyword">if</span> (exDebounceCount5 &lt; debounceValue) {
exDebounceCount5++;
}
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">in</span>DebounceCount1 &lt; debounceValue) {
<span class="hljs-keyword">in</span>DebounceCount1++;
}</pre>If I'm not mistaken, all of this code is pretty much useless--I never reset the debounce counters so none of these statements should ever resolve true. Hmmph. Something to play around with.<pre class="hljs cpp"><span class="hljs-keyword">if</span> (fireTimerCounter &lt; fireTimerOverflow) {
fireTimerCounter++;
}
<span class="hljs-keyword">if</span> (fireDelayCounter &lt; fireDelayOverflow) {
fireDelayCounter++;
}</pre>Fire timer stuff, relevant later on. Not much to say now.<pre class="hljs cpp">potentialTimerCounter++;
timer2Counter = <span class="hljs-number">0</span>;<span class="hljs-comment">//reset SLOW loop</span></pre>Iterate timers and reset the loop!<p><strong>Main Program: Fast Loop</strong></p><p>Okay, so I think I've made the assumption for a long time that this stuff happens really fast because it's inside this:</p><pre class="hljs cpp"><span class="hljs-prompt">if (TCNT1 &gt;</span>= timer1Overflow) {

}</pre>TCNT1 is the main timer, currently set to the AVR clock rate. BUT HERE'S THE THING--if timer1Overflow is only 10, and I've got more than 10 lines of code (or 10 clock cycles, which could probably be 1 line of crappy code) between the brackets, it will SLOW DOWN to the rate of program execution! I think that's why I've gotten thrown off by timing crap--my loop speed is getting stretched by a bunch of code. Which is shown in this section.<pre class="hljs cpp"><span class="hljs-title">potentialTotal</span> = decayPotential + inGroundState + exGroundState;
<span class="hljs-title">if</span> (potentialTotal &gt;= <span class="hljs-number">100</span>) {
<span class="hljs-title">fireTimerCounter</span> = <span class="hljs-number">0</span>;
<span class="hljs-title">decayPotential</span> -= inputMagnitude * <span class="hljs-number">4</span>;
}
</pre>We sum potentialTotal a lot, as it's in the fast loop. Also, this includes firing logic--if the total potential exceeds 100, firing happens and the decay plummets like crazy (to -280 with the current inputMagnitude value). I guess that's why changing the inputMagnitude value will affect sensitivity but NOT refresh rate. More on that later.<pre class="hljs cpp"><span class="hljs-title">if</span> ((potentialTotal == <span class="hljs-number">0</span>) &amp; (fireTimerCounter == fireTimerOverflow)) {
<span class="hljs-title">ledRedfade</span> = <span class="hljs-number">0</span>;
<span class="hljs-title">ledGreenfade</span> = <span class="hljs-number">100</span>;
<span class="hljs-title">ledBluefade</span> = <span class="hljs-number">0</span>;
}
<span class="hljs-title">if</span> ((potentialTotal &gt; <span class="hljs-number">0</span>) &amp; (fireTimerCounter == fireTimerOverflow)) {
<span class="hljs-title">ledRedfade</span> = potentialTotal;
<span class="hljs-title">ledGreenfade</span> = <span class="hljs-number">100</span> - potentialTotal;
<span class="hljs-title">ledBluefade</span> = <span class="hljs-number">0</span>;
}
<span class="hljs-title">if</span> ((potentialTotal &lt; <span class="hljs-number">0</span>) &amp; (potentialTotal &gt;= -<span class="hljs-number">100</span>) &amp; (fireTimerCounter == fireTimerOverflow)) {
<span class="hljs-title">ledRedfade</span> = <span class="hljs-number">0</span>;
<span class="hljs-title">ledGreenfade</span> = <span class="hljs-number">100</span> - (-potentialTotal);
<span class="hljs-title">ledBluefade</span> = -potentialTotal;
}
<span class="hljs-title">if</span> ((potentialTotal &lt; -<span class="hljs-number">100</span>) &amp; (fireTimerCounter == fireTimerOverflow)){
<span class="hljs-title">ledRedfade</span> = <span class="hljs-number">0</span>;
<span class="hljs-title">ledGreenfade</span> = <span class="hljs-number">0</span>;
<span class="hljs-title">ledBluefade</span> = <span class="hljs-number">100</span>;
}
<span class="hljs-title">if</span> (fireTimerCounter &lt; fireTimerOverflow) {
<span class="hljs-title">ledRedfade</span> = <span class="hljs-number">800</span>;
<span class="hljs-title">ledGreenfade</span> = <span class="hljs-number">800</span>;
<span class="hljs-title">ledBluefade</span> = <span class="hljs-number">800</span>;
<span class="hljs-title">fireDelayCounter</span> = <span class="hljs-number">0</span>;
}</pre>Remember how I said that Neuron LED colors fade in a non-linear fashion? Yup, this covers that logic. Green at 0, fades to Red approaching the action potential, fades to Blue during the refractory period, stays Blue when it's REALLY far into the refractory period, and fires like crazy when the fireTimerCounter drops. <p>Okay, this is a little trick. An earlier iteration was too bright--everything was indexed to full LED brightness. When I bumped the clock frequency up to 8 MHz from 1 MHz, I didn't change the 0-100 scale of LED brightness (or anything else), but I DID change the slow loop update frequency--as such, most of the time the LEDs run on a 12.5% duty cycle and no longer hurt your eyes when you're staring at a table full of them. However, I wanted flashes to be bright--now they stand out a lot.</p><pre class="hljs cpp"><span class="hljs-title">if</span> ((fireDelayCounter &lt; fireDelayOverflow) &amp; (fireDelayCounter &gt; fireDelayOverflow / <span class="hljs-number">2</span>)) {
<span class="hljs-title">PORTA</span> |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>);
}
<span class="hljs-title">if</span> (fireDelayCounter == fireDelayOverflow) {
<span class="hljs-title">PORTA</span> &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>);
}</pre>What happens when a Neuron fires? BAM! ACTION POTENTIAL! SEND A SIGNAL DOWN THE AXON! AKA, flip the second most significant bit of PORTA after a suitable delay. <pre class="hljs cpp">updateLEDs(timer2Counter, ledRedfade, ledGreenfade, ledBluefade);
timer2Counter++; <span class="hljs-comment">//increment SLOW loop</span>
TCNT1 = <span class="hljs-number">0</span>; <span class="hljs-comment">//reset FAST loop</span></pre>Run the LED update function (it runs a lot!), increment the slow loop counter, and reset the fast counter.<hr><p><strong>IF YOU MADE IT THIS FAR:</strong></p><p>I'm sorry, you've been on quite a journey. I couldn't sleep--for some reason, I had to drag myself out of bed to read through and document some code that I haven't take a critical look at in some time. This a great demonstration of the futility of documentation--even reading through my comments, it took me some time to grasp a few basic concepts about how the program operates, such as the ground potential functions.</p><p>Again--constructive criticism is encouraged. I've figured a few things out tonight:</p><ul><li>I need to combine things into functions more (duh)</li><li>It doesn't look like I ever fully implemented the debounce routine</li><li>I'm probably clogging up the fast loop, hence it running super duper slow style</li><li>Documentation is always worthy of improvement</li></ul><p>More to come--next time featuring videos of blinky Neurons!<br></p></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/3339/log/11874-neuron-v04-quick-overview">Neuron v0.4 quick overview</a></h2>
                            <small class="authorship">8 months ago  &bull;
                                <a class="gray-link" href="/project/3339/log/11874#discussion-list">
                                    0 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-11874"><iframe src="//www.youtube.com/embed/vPNMU431t4s" allowfullscreen="" frameborder="0" height="315" width="560"></iframe></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/3339/log/12054-planning-for-v05">Planning for v0.5</a></h2>
                            <small class="authorship">8 months ago  &bull;
                                <a class="gray-link" href="/project/3339/log/12054#discussion-list">
                                    0 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-12054"><p>Neuron v0.4 has been fantastic; the platform more than meets my expectations. The board has not developed any electrical issues, and the hardware design does not seem to constrain progress. The steep learning curve of AVR-C (and embedded programming in general) has taken up most of my attention, with eight-board build-outs providing a much-needed break between coding sessions. With that said, I've tried to keep track of a few gripes, roughly outlined here. </p><ol><li>The LED isn't great at being "RGB". Specifically, the red wavelength is about 20-30 nm or so too short; it's sort of an orange-red. During normal operation, the LED won't be seen with only its red element on, since (at least with the current firmware) that would occur very close to an action potential. However, the 70% level is a pretty common sight, since it's the point a single Exciter will hold; with a better RGB element, this might be more of a pure orange. If I can find something for &lt;$0.25 each that fits this criteria, I think it's worth a shot.</li><li>Bigger pads. Everywhere. The current board design has enough room between components that I can at least stretch the standard footprints out a bit to improve reworkability. Pulling the dropping resistors away from the LED a bit might be necessary. </li><li>More on-board axon connections! Maybe a dedicated axon with a built-in terminal that ends in wired plugs rather than header--this would be fairly easy to construct with a bit of heat shrink to connect a bundle of standard axon halves. Or just 2-plug, 4-plug, and 6-plug axons, with the 4- and 6- units having one longer lead to connect to the upstream Neuron.</li><li>Cheaper. Always cheaper, if I can swing it. That means looking at the most expensive bits--the circuit board, then the microcontroller, then the LED, then a lot of space before the passives and connectors. </li><li>Improved programming interface. I think a <a href="http://www.tag-connect.com/TC2030-IDC-10">commercially available PCB-based solution</a> might serve me best--the cheapest option at scale since it just requires a bit of drilling and de-masking, and fast for programming lots of units in series. </li><li>More flexibility on the dendrite side. I've thought about this most of all, even though it's not the highest priority right now since I rarely, even with 30+ Neurons, fill all six Dendrite headers on a single board. Here's the thing--I think I'm mostly constrained by item (3) on this list right now. My Axon Terminal design isn't fantastic--broken perf board bits with heat shrink and a few headers, meaning each one requires <em>three additional</em> Axons to function completely. But if I fix this problem, I'll start using tons of 4-plug and 6-plug axons in my designs, and the Dendrite constraint is really tough--since I take up an entire I/O line for each Dendrite, I'll need to use a different (or multiple) chips to gain I/O. Or cascade branches of Neurons, adding potentially unwanted delays to a loop. Or building dedicated 'high volume' Neurons, which would double the firmware sets (even if they're only slightly different) I'd need to maintain, and increase the BOM length and the number of circuit board designs...</li></ol><p>So I started mulling it over and think I could drastically change the electrical design of the Dendrite system. Rather than looking for incoming voltage pulses on an upstream Neuron, I could build some kind of a circuit that utilizes the onboard ADC to figure out how many simultaneous signals are getting to a big parallel bus. </p><p>More to come!<br></p></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/3339/log/12067-more-thoughts-on-v05">More thoughts on v0.5</a></h2>
                            <small class="authorship">8 months ago  &bull;
                                <a class="gray-link" href="/project/3339/log/12067#discussion-list">
                                    8 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-12067"><p><em>WARNING: This is a long post related to future planning and likely will not be acted on for some time. Most of the ideas below haven't been thoroughly thought through (wowsers), so read at your own risk. </em><br><strong></strong></p><p>I haven't abandoned v0.4; I'm roughly 60% through the production run and as I covered in the previous post, no game-ending issues have popped up. I'm going to keep using the current iteration until... well, who knows? Until its constraints get too frustrating. More likely than not, I won't consider actively developing a new iteration until ~120 Neurons is no longer enough to hold my interest. Having said that, I couldn't sleep last night and did a bit of 1:00 AM whiteboard brainstorming which I'll decipher in this log update.</p><p><img src="https://cdn.hackaday.io/images/2031891419203882633.JPG"></p><p>I'm going to go through the ideas here (I had enough presence of mind to number them chronologically). This post will serve as a reminder, more than anything--future Zach, make sure you think about this stuff before ordering the next generation of PCBs. Apologies, as always, for the poor quality of the whiteboard pictures...</p><hr><ol><li>New PCB concept drawing<img src="https://cdn.hackaday.io/images/7801231419203443040.JPG"><ol><li>ATtiny13A--the cheapest of the ATtiny series, and surprisingly it doesn't seem to be cheaper than the 44A in similar quantities. In any case--the idea is to back the I/O count down as much as possible. I suppose as pictured, I'd still need 8 I/O lines--three Dendrites (including the Learn Mode connector), two Axon options, and the RGB LED. Maybe the 44A is still the right call.</li><li>Big deal here--each dendrite type has one connector rather than many. I'll get in to more details later, but this design includes some type of external splitter that allows multiple signals to feed a single dendrite. </li><li>More on 'learn mode' later, too.</li><li>The inhibitory axon is lower priority--that would complicate a lot of things but might prove interesting. Idea is--plug an Inhibitory Axon into an Excitatory Dendrite and it--does what? TBD, I suppose.</li></ol></li><li>Notes on the dendrite system<img src="https://cdn.hackaday.io/images/443631419204186930.JPG"><ol><li>So... the new dendrites will use the ATtiny platform's built-in 10-bit analog-to-digital capability. That means they'll be looking at voltage inputs between 0 and 5vdc.</li><li>The analog front-end--that's the detail I'm conveniently skipping over here. This part of the system will convert simultaneous dendritic excitations into a proportional voltage response using some as-of-yet nonexistent circuit. One complicating factor--I still want exciters to work!</li></ol></li><li>Options for excitatory and inhibitory dendrites<img src="https://cdn.hackaday.io/images/4457441419204351288.JPG"><ol><li>See drawing (1) on the right? Yup, this relates to the two dendrites on v0.5.</li><li>Here's the idea--I want to be able to plug a single unbranched (/simple) axon into either of these dendrites and have it work, but I also want to be able to split the dendrite. Maybe call the split version a 'soma', since that is the cell wall that dendrites branch out from?</li></ol></li><li>Drawing conventions<img src="https://cdn.hackaday.io/images/823641419204468556.JPG"><ol><li>Lest anybody gets confused, these are the 'schematic symbols' I'm using tonight. To be clear--plugs live on the ends of wires, while headers are soldered to PCBs.</li></ol></li><li>Dendrite expander idea<img src="https://cdn.hackaday.io/images/2752951419204524849.JPG"><ol><li>This part could connect to the inhibitory and excitatory dendrite headers on the board. See? 1-to-5! Maybe I could make a few different standard split ratios--1:3, 1:5, 1:8, etc? </li><li>One key idea here--separate the splitter board from the wire/plug. Not drawn but indicated with an arrow--splice a plug onto both ends of the wire, then put an input header on the board? Might bring down overall mfr costs and make everything a bit more modular?</li></ol></li><li>Thinking about synapses and weighting<img src="https://cdn.hackaday.io/images/4149301419205137626.JPG"><ol><li>Linked via twisty arrow to idea (2). </li><li>More far-out ideas here--making the axon-dendrite interface (synapse) something other than a 'perfect' conductor. </li><li>If 'weighting' can be done using resistance--maybe use CdS cells as passive weighting components? I suppose cadmium doesn't go with RoHS, huh? Would the LEDs from other Neurons throw this off?</li><li>Ideally--do 'weighting' in software (learning mode) AND hardware. How?</li></ol></li><li>v0.5 dendrite circuit (see below)</li><li>v0.5 axon terminal circuit (see below)</li><li>v0.5 axon (board level) circuit<img src="https://cdn.hackaday.io/images/4638621419205320195.JPG"><ol><li>Pretty basic block diagram of a potential inter-Neuron circuit. </li><li>Circuit "A", in the Neuron dendrite system, would convert the number of simultaneous inputs (either signals or exciters) into a proportional voltage, as shown in the graph on the lower right.</li><li>Circuit "C", in the Neuron axon system, would allow each Neuron to add to the total voltage produced by "A" when its Neuron fires. </li><li>Circuit "B" would allow multiple Neurons to send signals to a single downstream Neuron. What to call this? 'Soma'? </li></ol></li><li>Dendrite clusters and axon terminals<img src="https://cdn.hackaday.io/images/193781419205556123.JPG"><ol><li>Basic terminology--Dendrite Clusters are the input splitters shown in idea (5), while Axon Terminals are standard axons pre-soldered in parallel.</li></ol></li><li>More on dendrite clusters<img src="https://cdn.hackaday.io/images/3353641419205624932.JPG"><ol><li>Yup, just added on to idea (5) here. Not much beyond the headers being in parallel with passive components as necessary (no microcontroller!). I want these to be scalable as needed!</li></ol></li><li>More on axon terminals<img src="https://cdn.hackaday.io/images/7708431419205754751.JPG"><ol><li>I described this under idea (10)--just illustrated here. Ideally, everything is passive and in parallel like it is today! </li><li>Do I need both Axon Terminals AND Dendrite Clusters? What about a 'splitter' and an extending Axon?</li></ol></li><li>Overall goals for v0.5--big picture<img src="https://cdn.hackaday.io/images/8437191419206101249.JPG"><ol><li>Every Neuron version has been cheaper than the previous. Well, except v0.1. In any case, I don't want to break that cycle--as such, recreating one of the v0.4 units should not be more than ~$3.50 or so.</li><li>In ideas (7), (8), and (9) I showed a proposed block diagram of the new interconnection system. If I can make circuit "B" in (8) unnecessary, then the "dendrite clusters" and "axon terminals" will just be parallel circuits--that makes manufacturing really simple and cheap and (hopefully) scalable.</li><li>Cheap passives--circuits "A" and "C" are additions to the v0.4 design! Gotta make 'em as cheap as possible! That means no extra microcontrollers!</li><li>More flexibility with connections--duh. That's the whole point. Some Neurons only have one dendrite. Some have TONS of dendrites. I need both options!</li><li>The bonus would just be cool. Some kind of modular circuit that would change the weighting of a given input (or inputs). That gets closer to emulating real-world synapses--as in, not every connection is made equal.</li></ol></li><li>Can they learn?<img src="https://cdn.hackaday.io/images/3997291419206452190.JPG"><ol><li>You can't tell in this image (refer to the master whiteboard picture at the beginning of this log update), but this idea is waaaay over on the other side of the board.</li><li>Learn Mode signal--the best comparison I can make is the <a href="http://en.wikipedia.org/wiki/Highway_Addressable_Remote_Transducer_Protocol">HART protocol</a>, since it overlays a digital signal over an analog signal. Same idea here--dendrites and axons behave as they did previously, but they can also send a coded message that downstream Neurons will recognize to switch modes.</li></ol></li><li>Don't forget to remove blue painter's tape<img src="https://cdn.hackaday.io/images/228681419207019126.JPG"><ol><li>This happened when I taped a piece of paper to my whiteboard a few months ago. Normally I just avoid the area, but I needed the whole sheet for this brain dump--as such, it's marked as the Whiteboard Damage Zone.</li></ol></li><li>Dendrite waveform<img src="https://cdn.hackaday.io/images/4545911419207085788.JPG"><ol><li>Here is what you might see if you snoop a dendrite with a 'scope. Note that the voltage is quantized to a degree, allowing us to differentiate between the number of inputs sending active signals (exciters AND action potentials!).</li></ol></li><li>Learn mode signal<img src="https://cdn.hackaday.io/images/6797851419207384459.JPG"><ol><li>Extended from the previous image--the 'fast tone' just needs to be unique. As in, something that wouldn't be recreated by normal Neuron activity--maybe ten state changes in a certain number of milliseconds or something.</li><li>How many modes? Maybe two--Learn and Run. Two different tones for different modes, or a toggling set up? </li></ol></li><li>Learn mode signal networking<img src="https://cdn.hackaday.io/images/5349181419207483846.JPG"><ol><li>Should Learn Mode (and Run Mode) signal propagation follow the standard network? As in, if a Neuron is placed in Learn Mode, all downstream Neurons are placed in the same mode?</li><li>Seems like electrically, the Learn Mode signal should propagate as we want it to without any special software considerations--all downstream Neurons would get the signals, but since Axons don't listen any lateral Neurons wouldn't get the message.</li><li>What happens during Learn Mode? Maybe it's identical to Run Mode, but input weighting changes based on action potential frequency? How can we adjust input weighting when dendrites are in parallel?</li></ol></li><li>Learn mode propagation diagram<img src="https://cdn.hackaday.io/images/5390331419207648706.JPG"><ol><li>A bit blurry, oops. Black squares are Neurons, blue lines are standard Axon--&gt;Dendrite connections, and green lines are Learn Mode signal propagation.</li><li>New peripheral--the Learning Remote! Used to inject Learn Mode signals into a given Neuron.</li></ol></li><li>Learn mode features<img src="https://cdn.hackaday.io/images/9567851419207730564.JPG"><ol><li>Also blurry--sorry.</li><li>Describes what happens in Learn Mode--Neurons behave normally but would start increasing input weights.</li><li>Again--how do we differentiate between individual Dendrite connections? Would this setup only work with unique inputs (as with v0.4)?</li><li>Learn Mode Jumpers--connect standard signals to the Learn Mode input (see idea (1)) and ONLY Learn Mode signals will be 'heard'. Allows Learn Mode to propagate to non-connected network sections. </li></ol></li><li>Local/regional learning!<img src="https://cdn.hackaday.io/images/7535821419207869203.JPG"><ol><li>This picture got a bit stretched and is super blurry. Sorry.</li><li>This connects to the diagram in idea (19)--it just shows linking Learn Mode jumpers to a normally unconnected neural network.</li><li>Seems like a 'bonus feature'. </li></ol></li></ol><hr><p>Okay--back to v0.4 soon, I promise. With any luck, I'll reference these ideas when I take the next steps in v0.5 development. I think the analog input concept could improve network flexibility--it would be nice to have 10+ dendrite Neurons without specialized boards or programs. But for now, that's a solution lacking a problem.</p><p>Zach<br></p></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/3339/log/12158-22-neuron-v04-test">22-Neuron v0.4 Test</a></h2>
                            <small class="authorship">8 months ago  &bull;
                                <a class="gray-link" href="/project/3339/log/12158#discussion-list">
                                    0 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-12158"><p>I have a bunch more Neurons, but I unexpectedly ran out of Axons; I crimped up a few more and remembered how long they take to manufacture, so I got lazy and stopped at 22 elements for this test.  </p><iframe src="//www.youtube.com/embed/bncZd_gKRUw" allowfullscreen="" frameborder="0" height="315" width="560"></iframe><p>This video is pretty straightforward (and quite short!); I arranged 22 Neurons into a loop, making a few modifications as I went:</p><ol><li>All Neurons are equipped with Exciters; as such, they are deep yellow (indicating the current membrane potential level of 70%).</li><li>I numbered the Neurons counter-clockwise starting with the first one to pulse (triggered by the snap action switch). Neuron #5 is split using an Axon Terminal; part of its output recycles to an excitatory dendrite of Neuron #1. This makes the loop self-sustaining, sending periodic pulses down the chain to Neurons #6 through #22.</li><li>Neuron #22 sends its pulses to the inhibitory dendrite of Neuron #3; this is timed such that the pulse arrives right before Neuron #2's excitatory pulse, effectively 'quenching' the loop.</li><li>I hooked my ammeter up to the power cord's current measurement loop; you can see the current spikes caused by each excitation, since the LED brightness goes from 12.5% to 100%. Resting current draw is ~6.5 mA per Neuron--not bad!</li></ol><p>And so: click the switch, get four pulses! Well, five pulses. Pulse #5 gets shot down by pulse #1.</p><p>Blinky.</p></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/3339/log/17764-this-project-very-much-still-alive">This Project: Very Much Still Alive.</a></h2>
                            <small class="authorship">3 months ago  &bull;
                                <a class="gray-link" href="/project/3339/log/17764#discussion-list">
                                    0 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-17764"><p>I glanced through my project logs and realized that I haven't posted much about this project in some time. That is lame.</p><p>You know what is <em>even more lame</em>? <a data-mention-user-id="46737" href="/hacker/46737">@NeuroJoe</a> and I have been working on it like crazy. For example, I managed to go 12 for 12 in Neuron v04 manufacturing the other day:</p><p><img src="https://cdn.hackaday.io/images/1667601431457559708.jpg"></p><p><em>(side note: yup, they draw a lot of current at full brightness. This is just a test program that double-checks LED wiring.)</em></p><p>So. I don't have much else to say <em>here and now</em>, but I'm committing to a comprehensive project update by the end of the week. Or weekend. Or something like that. NEAR FUTURE, okay?</p><p>So stay tuned, eh?</p><p>-z<br></p></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/3339/log/22629-neurotinker-grants-progress-excitement-etc">NeuroTinker, Grants, Progress, Excitement, Etc.</a></h2>
                            <small class="authorship">6 days ago  &bull;
                                <a class="gray-link" href="/project/3339/log/22629#discussion-list">
                                    0 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-22629"><p>Radio silence on Neurons throughout most of summer. I still owe this project page a major update. Rather than wasting [too much] time with excuses, let&apos;s get started bringing everyone who may be interested up to speed.</p><p><span class="redactor-invisible-space">Back late 2014, I got an email from <a href="https://www.bc.edu/schools/cas/biology/facadmin/burdoj.html">Joe Burdo</a> about this page. He&apos;d been working on a similar project at BC; in his case, he developed a physical neuron simulation for use in a freshman course studying central pattern generator circuits in fish. He had produced a few prototypes and gotten a complex neural circuit to work, but wanted to take development further and was new to the world of electronics and manufacturing. We corresponded at length over winter, eventually coming to the conclusion that our respective skillsets complement each other nicely: he has a PhD in neuroscience in addition to over a decade in the classroom (quite qualified), while I have puttered around with electronics for a good bit of my life (... qualified?). I flew out to Boston, we met up for the day, and we decided to start a collaboration.</span></p><p><img src="https://cdn.hackaday.io/images/3295461439422181522.png"></p><p><strong>That&apos;s us. </strong><a href="http://www.neurotinker.com/">NeuroTinker, LLC</a>. Our site is a bit sparse right now, but we&apos;re slowly building up content and getting background information filled in. We hired my excellent cousin Lauren Everett to design our logo and put together a basic website framework; she did an excellent job (as you can see) and was terrific to work with. </p><p> So what&apos;s the plan? We want to develop an educational platform that gets people into neuroscience. We want it to be modular, economical, scientifically accurate, fun, open-source, and accessible to a broad range of educational achievement levels. While chemistry students pick up their <a href="https://en.wikipedia.org/wiki/Molecular_model#Models_based_on_ball-and-stick">ball-and-stick model kits</a> from the campus bookstore, aspiring neuroscientists will get NeuroBytes.  </p><p>How do we do that? We get NeuroBytes into the hands of lots of students as quickly as possible. We figure out how to use the platform to model real parts of the nervous system. We add new modules and sensors and outputs and try to build something exciting and engaging. We iterate a lot. I (by necessity) learn a lot more about microcontroller programming. We talk to educators and figure out what might improve the classroom experience.</p><p>As of today, we&apos;ve heard back from a few dozen educators across a wide range of institutions who all seem quite stoked about the concept. We have applied for two SBIR Phase I grants focusing on different specific areas of educational technology (but we probably won&apos;t hear back for a few months). We sold six NeuroBytes v04 prototypes for integration into a Crazy Project (Crazy Project owner, feel free to comment if you wish). And we built more NeuroBytes:</p><p><img src="https://cdn.hackaday.io/images/1463811439424293846.jpg"></p><p>and worked on some new NeuroBytes interfaces:</p><iframe style="width: 500px; height: 281px;" src="//www.youtube.com/embed/OGH6bdYnPho" allowfullscreen="" frameborder="0" height="281" width="500"></iframe><p>I&apos;m hoping to have a firmware update pushed out in the next week or two; this revision will include the servo driver test code shown above along with a to-be-developed Motor NeuroBytes module setup.</p><p>Woo!<br></p></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/3339/log/22643-patellar-reflex-model">Patellar Reflex Model</a></h2>
                            <small class="authorship">6 days ago  &bull;
                                <a class="gray-link" href="/project/3339/log/22643#discussion-list">
                                    0 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-22643"><p>Okay, quick update. I added a linear decay function to the Motor NeuroBytes module (the servo output) and cut a little leg model out of matteboard:</p><iframe style="width: 500px; height: 281px;" src="//www.youtube.com/embed/ntEUOtO8JJA" allowfullscreen="" frameborder="0" height="281" width="500"></iframe><p>It&apos;s quite simplified as it doesn&apos;t illustrate the inhibitory portion of this reflex, but the model does make the whole project seem a bit more real.</p></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/3339/log/23727-patellar-reflex-model-part-2">Patellar reflex model, part 2</a></h2>
                            <small class="authorship">4 hours ago  &bull;
                                <a class="gray-link" href="/project/3339/log/23727#discussion-list">
                                    0 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-23727"><p>I putzed about with the Motor NeuroBytes firmware a bit tonight:</p><iframe style="width: 500px; height: 281px;" src="//www.youtube.com/embed/Ft3oDAPxWq4" allowfullscreen="" frameborder="0" height="281" width="500"></iframe><p>This program is called v04run_servo-ex-inh in the Github repo. In the video, I&apos;ve attached twoNeuroBytes in series in such a way that one excites the next while the first excites the Motor NeuroBytes module and the second inhibits it. A few notes:<br></p><ul><li>Inhibiting or exciting the Motor NeuroBytes 
immediately moves it to 100% or 0% from its normal resting position of 
50%. I&apos;m guessing that each inhibition or excitation should actually 
move the current state by x amount, kinda like the current standard 
NeuroBytes firmware just shifts the immediate resting point of the board
 by 70%. In other words, exciting or inhibiting the Motor NeuroBytes 
board should produce a relative rather than an absolute change.</li><li>Standard
 NeuroBytes insert a delay between the LED pulse and the axon output, 
which makes the flashes out of phase with the Motor NeuroBytes module 
movement. Might make sense to move the delay to the input side--as in, 
you hit the button and the NeuroBytes module doesn&apos;t instantly react, 
but when it does it immediately dumps a pulse down its axon.</li></ul><p><span class="HOEnZb">So. More to come.<br></span></p></div>
                            </div>
                        </li>
                    
                </ul>

                
                <div class="pagination">
                    
                    <a href="?page=1" class="grey-gold-button prev-button show">Previous</a>
                    
                    
                </div>
                

                

                </p>

            
        </div>
    </div>

    










<div class="footer" id="footer">
  <a href="#header" class="back-to-top" onClick="CT(this, 'Footer', 'GoingUp');">^ Going up? ^</a>
    <div class="container">
        <p><a href="http://hackaday.com/about/">About Us</a> <a href="mailto:projects-contact@hackaday.com">Contact Us</a> <a href="/project/37">Give Feedback</a>&copy; 2015 Hackaday <a href="/tos">Terms of Use</a> <a href="/privacy-policy">Privacy Policy</a></p>
        <a href="/" class="had-skull"  onClick="CT(this, 'Footer', 'Home' ); return false;">Hackaday.io</a>
    </div>
</div>

<script>

    var csrftoken = 'gELHKufi-CrdZ9FwRXE9PLNjY_XTbbihQbc0';

</script>

    <script type="text/javascript">

    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-47229708-1', 'auto');

    var dimensionValue = 'nonregistered';
    ga('set', 'dimension1', dimensionValue);
    ga('require', 'displayfeatures');

    ga('send', 'pageview');

    </script>

<img src="//analytics.supplyframe.com/trackingservlet/impression?action=pageImpression&amp;zone=HIO_logs&amp;extra=logged%3Dfalse%7ChaveAccountCookie%3D0%7C&amp;ab=undefined" class="sf-impression" />

    
    
    <script src="//cdn.hackaday.io/build/h%2FydgsYIeDTf7pqgYQEKK8Ngblw0IkZCDqfJ9S2tk7zsBoxIHt5iOd49Qp%2BF4vdxEuRj%2BGpGDLbX4aGOQGmbjaOxUZvklg4ReFk68R95OQshFrGKebvogKGQOiB5Hi1xym9KC54c9Ps0WpzuNydLk4B%2FbKi91KhV40Uxhl38XXb1IVAxAI8iW%2BoQUPCFkHVWZxD0B%2BMZ%2BuEXJTlWuBmopNMxTHRK5yleITPZODT6evbVRQc6AXs9w2Pfk7FS2nKy-0.48.6.js"></script>

</body>
</html>