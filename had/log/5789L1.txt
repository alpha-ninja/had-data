<!doctype html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if IE 9]>    <html class="no-js ie9" lang="en"> <![endif]-->
<!--[if gt IE 9]><!--> <html class="no-js" lang="en" ng-app="buildlogApp"> <!--<![endif]-->
<head>
    
    <title>Project logs &bull; 6502 Homebrew Computer &bull; Hackaday.io</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="//cdn.hackaday.io/css/style.css?version=0.48.6" />
    <script type="text/javascript" src="//use.typekit.net/ymb0lgk.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
</head>
<body class="logs">

    <!--
############################################################################################
############################################################################################
############################################################################################
#####################Kt;tL#######################################Kti,E######################
#######################;   .###################################G    E#######################
#######################K    f##################################    ;########################
########################Wj   E###############################K:  .W#########################
##########################.  :E##############################:  .L##########################
#########################D    f##############################.   .##########################
########################,     ;##############################     :E#######K################
################f######K      ,##############################      ,######Lt################
################  W###W       i##############################       t####j t################
################:  E#L.        f###########################L.        f#Ki .E################
################j  ;E.          j##########################.         .G;  i#################
#################L               i#######################K                ##################
#################W                E#####################K;               ;##################
###################:               .###################D               :f###################
#####################DLfGD           G####WEEEEKW####W           ;GffGK#####################
##########################i         iD##Kfi    :jKW##D          iE##########################
###########################W      ,G##f            jE#E;       j############################
############################L     D##D              ,##K       W############################
#############################D:  G#W                  K#E,   G##############################
###############################;i#L                    j## ,E###############################
###############################KK#.                     ##iE################################
#################################j                      ;K##################################
################################W                        ,##################################
################################E                         ##################################
###############################Ki                         D#################################
###############################E.                         L#################################
###############################f    iD##W;       D###D    :#################################
###############################i   i######K     K#####K;   #################################
###############################;  .E#######     #######D   #################################
###############################;  L########     ########   #################################
###############################i  G#######K     K#######   #################################
###############################j  L#####E,       fE#####   #################################
###############################D  .E##j            .t##E  ;#################################
###############################E:  ;##.              #Wt  j#################################
################################G   ;t      tWi      t    E#################################
#############################KL##           K#K;          #K:K##############################
#############################i ##:          ###t         j#f ;K#############################
############################:  G#K          #E#L        L##    D############################
###########################D   ;W#:         #;#L        W#K    .############################
#####################KKEKK      :##L        ; ..      :D##.      fKEEK######################
###################t.            ;##G:               ,##E,             tD###################
##################G               E##E               i##;               :###################
#################D                W##W    iL    E.    ###D                ##################
################W,               G###W    tG    K.    ####:               K#################
################;  LW;         ,E#####:  ;W#    #G   f#####;         ;KG  :K################
################  D###E       ;########WW####WW####WW#######W       :####: j################
################ ,#####:      ;##############################       G####E i################
################K#######.     ;##############################      L######WG################
########################f     i##############################     j#########################
#########################W   .D##############################.   i##########################
#########################E   G###############################D   ,##########################
########################G:   #################################j   G#########################
#######################f    K##################################j    W#######################
#####################Kt :iE#####################################KL:  K######################
############################################################################################
############################################################################################
############################################################################################
-->

<div class="header" id="header">
    <div class="container">
        <h1 class="logo">
            <a href="/" title="Hackaday.io Home" class="home" onclick="CT(this, 'Menu', 'Home'); return false;"></a>
            <a href="/" title="Hackaday.io Home" class="brand" onclick="CT(this, 'Menu', 'Home'); return false;">Hack a Day</a>
        </h1>

        <a href="javascript:void(0);" class="responsive-menu">Menu</a>

        <ul class="nav" role="navigation">
            <li><a href="/projects" class="">Projects</a></li>
            <li><a href="/lists" class="">Lists</a></li>
            <li><a href="/stack" class="">Stack</a></li>
            <li class="dropdown more-nav j-more-open">
                <a href="javascript:void(0)" class="dropdown-link icon-dropdown">More</a>
                <ul role="menu" class="dropdown-menu more-menu" id="j-more">
                    <li><a href="http://hackaday.com/blog/" target="_blank">Blog</a></li>
                    <li><a href="/events">Events</a></li>
                    <li><a href="/hackerspaces">Hackerspaces</a></li>
                    <li><a href="/hackers">Profiles</a></li>
                    <li><a href="/contests">Contests</a></li>
                    <li><a href="/prize" target="_blank">The Hackaday Prize</a></li>
                    <li><a href="/submissions/prize2015/list">2015 Prize Entries</a></li>
                </ul>
            </li>
            <li class="menu-last-child">
                <div class="search-holder show">
                    <form id="search-form" action="/search" onsubmit="return submitSearch();" method="GET">
                        <input type="text" placeholder="Search" name="term" class="input-search j-add-search" id="j-add-search" value="" autocomplete="off" pattern=".{3,}" required title="3 characters minimum" />
                        <input type="submit" class="search-button" />
                    </form>
                </div>
            </li>
        </ul>

        

            <ul class="nav pull-right" role="navigation">
                <li><a href="/signup" class="grey-white-button become-member">Sign up</a></li>
                <li><a href="/signin?returnUrl=%2Fproject%2F5789%2Flogs%3Fpage%3D1">Sign in</a></li>
            </ul>

        
    </div>
</div>

<div id="topMessage" class="alert"><span class="j-top-content"></span><a href="javascript:void(0);" class="alert-close j-top-message-close">Close</a></div>




    <div class="headline">
        <div class="container">
            <h2><a href="/project/5789-6502-homebrew-computer">6502 Homebrew Computer</a></h2>
            <p class="description-title"> Project logs</p>
            <p class="description-summary">My own design 6502 based computer, using scavenged bits for some 80s nostalgia</p>
            <div class="description-metainfo">
                
                    <span>created by <a href="/hacker/68147-dolo-miah" title="Visit Profile">Dolo Miah</a><span>&bull;</span>
                
                3 months ago<span>&bull;</span><a href="/project/5789#discussion-list" title="See Comments">9 Comments</a></span>
            </div>
        </div>
    </div>

    <div class="container post-content">
        <div class="section-buildsort">
            <span class="pull-left">
                <a href="/project/5789-6502-homebrew-computer">&#171; Back to project details</a>
            </span>
            <span class="sort-holder pull-right">
                <label for="sort-by">Sort by:</label>
                <select class="sort" id="sort-by">
                    <option value="/project/5789/logs/sort/newest">Newest</option>
                    <option value="/project/5789/logs/sort/oldest" selected="selected">Oldest</option>
                </select>
            </span>
        </div>
        <div class="section section-buildlogs last">
            

                <ul class="buillogs-list">
                    
                        <li>
                            <h2><a href="/project/5789/log/18021-the-basics">The Basics</a></h2>
                            <small class="authorship">3 months ago  &bull;
                                <a class="gray-link" href="/project/5789/log/18021#discussion-list">
                                    0 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-18021"><p>Although this is an on-going project, I have been working on it for over a year before publishing anything, so I'll try and capture some of my approach, experiences and lessons learnt to bring this site up to date. </p><p>One thing I have been doing over the life of this project is trying to do it on a shoe-string budget.  That's just the way I am - a bit of a tight-arse who likes to think he's got a bargain of some sort!  However whilst being budget conscious is great in nearly any setting, it has to be with some level of pragmatic trade off and risking the saying of 'buy cheap, buy twice' coming in to effect.  So I learned by trial and error the right budget trade off!  I don't know how much I have spent on this hobby, but I am sure it has to be approaching £250-300 by now.</p><p><strong>In the beginning..</strong></p><p><strong></strong>I started off with literally nothing - no components, no tools, no experience.  But I did a lot of reading.  The internet is fantastic, so many people willing to put their experience and knowledge out there on the web for the rest of us to benefit from.  I can't possibly remember or list every resource I have examined, but over the course of this project <a href="http://www.6502.org">www.6502.org</a> has been a fantastic well of knowledge.</p><p>Initially I needed to get some kit together.  I bought a bunch of basic components (resistors, capacitors, transistors, 555 timers, crytals, LEDs etc.) with some wire (solid core, multi-colour).  I also decide to use breadboards to try out my experiments (as they were right at the beginning).  I love breadboards, but I'll mention some of the problems I have with them later, they're not all good!</p><p>Despite working in IT professional services - where I often have to spend weeks or months architecting and designing solutions - I spent virtually no time thinking about the design features of my computer (perhaps it was a back-lash to my day job!).  I had some key features in mind, some mandatory otherwise it wouldn't be a functional computer, and some that I wanted to make it useful.  What useful meant was the ability to program some 1980s style rudimentary video games, complete with sound effects.  So the features: </p><ul><li>It had to have a CPU (!), a 6502 one (see below)</li><li>It had to have memory (!), but how much I hadn't decided</li><li>It had to have some IO (!), but for what purposes I hadn't decided</li><li>It had to have video graphics output.   I had homebrews which used small LCD panels or no video at all - this wouldn't for me as I wanted to be able to play video games on it!</li><li>It had to have sound output output.  Again, I had seen homebrews which didn't care much about sound, but I wanted this.</li></ul><p><strong>CPU</strong><br></p><p>So, I had some basic electronic components, but no complex ICs like a CPU, memory etc.  Looking through a number of existing homebrew sites, I could see a variety of CPUs had been used including  6809, 8080, 68000.</p><p>However fascinating these other projects were, I had already resolved to use the 6502 at the heart of my project.  The reason is straightforward nostalgia.  My first computer was a 6502 based micro called the Oric-1, bought for £80 in a knock down sale in 1984.  I was 13, and knew nothing about computing, but convinced my hard-up parents that I needed one, and this was in the right price bracket (i.e. really, really cheap).  But this computer took me from never having written a BASIC program to being able to code assembly in hex (because I couldn't afford an assembler - eventually wrote one for myself).  When I grew out of the Oric-1, I got an Atari 800XL in 1985, which was also 6502 based.</p><p>Aside from nostalgia, I could see that with everything else I was going to have to learn to be able to build my own computer, having something I was already familiar with would be a good thing.</p><p>The first one I bought was off ebay (where most of my acquisitions of components etc. were made) - a CMOS based Rockwell model.  However, during my investigations, I also found out that a company called the Western Design Center was still producing 6502 CPUs which could operate at much higher clock speeds than the original 1-2MHz in the 80s.  For this main reason, I ended up using a WDC 6502 piece (there is a story behind why I thought I needed the higher clock speeds - will go in to that in another log).</p><p><strong> Memory</strong></p><p>Choosing RAM was straightforward enough.  On ebay UK, there are a couple of sellers who provide 'hombrew computer kits'.  These kits provide a CPU (typically a Z80), some glue chips (typically PLDs) some support chips (video, RS232, IO), some ROM and some RAM.</p><p>The supplied RAM is typically SRAM and the ROM is typically EEPROM.  Neither SRAM nor EEPROM were very common in 80s microcomputers.  However, DRAMs are difficult to both obtain and use - DRAMs need refesh circuitry which would add complexity (6502 has no refresh capability built in, although I understand the Z80 may well have).  So I decided that in the interests of pragmatism, SRAM would be fine - I'm not trying to recreate a 100% 80's replica.</p><p>The supplied ROM is typically EEPROM.  However, before purchasing one of these kits, I had decided that I would buy some EPROMs, a very cheap multi-format PROM programmer and a basic UV eraser.  This is because of experience with my first job after graduating, working as an embedded systems programmer.  In this job I would burn EPROMs and erase with a UV unit - I figured this would be how I would do things in 2014!  Anyway, I will cut a long story short, due to the unreliability of probably 10+ year old EPROMs and the long build/burn/erase cycles, I turned to EEPROM.  The so-called multi-programmer I had couldn't burn EEPROM, so I had to invest in some proper German (and so expensive - around £130) kit that I could rely on.</p><p><strong>I/O</strong><br> </p><p>Without I/O there is no point to a computer of course.  So I had decided originally that a 6522 (ebay sourced) would be fine with an RS-232 interface for serial comms.  What I didn't do was to realise that RS-232 was a pain due to the voltage differences and the fact that my modern computer doesn't even have RS-232!  I was also unaware that the 6522 serial capabilities are both flawed and limited, so that I may have to 'bit bang' the I/O without some kind of serial interface IC like a 6551.  In the end, I ditched the 6522 in favour of two 6526 (close relation to the 6522) out of a non-working C64.  At the time I didn't have access to a 6551 so had to do a bit of funky wiring to get that working.  Although I will add a 6551 at some point, it is working well enough for now so it will be a lower priority than things like sound.</p><p>However, the serial data capabilities on my development PC (modern laptop running Win7) only suppports high speed USB.  I had to buy a USB serial adaptor cable - which are commonly used for Arduino development.  Not expensive - less than £3.</p><p>The 6526s together currently provide the following functions:</p><ul><li>TImer A in both 6526s is used for the serial input output timing.  When I get a working 6551 in, this timer will become free</li><li>In 6526-1, all 8 bits of Port A are used to enable the keyboard row and column addressing</li><li>In 6526-1, 3 bits of Port B are used to control the leds on the BBC keyboard</li><li>In 6526-1, 1 bit of Port B is used to sense the key pressed for a row and column</li><li>In 6526-1, /FLAG is used to sense when serial input is available. Will become when I used a 6551</li><li>In 6526-2, all 8 bits of Port A are needed to provide a bi-directional databus to communicate with the sound chip</li><li>In 6526-2, 2 bits of Port B are needed to control the select signals to the sound chip</li><li>In 6526-2, /FLAG used to sense when the BBC keyboard hardware strobe senses some key has been pressed.</li></ul><p>When I used a 6551, then I will move the keyboard signal from 6526-2 to 6526-1.  What way all keyboard access is through a single CIA (somehow feels a bit neater / elegant, although has no material effect on the code structure!).</p><p>I have now replaced the 6526 based I/O with an ACIA.  And also added a keyboard from an old BBC Micro.  The BBC Micro keyboard is actually very cool - it has some basic circuitry which means it scans for a key press in hardware, generating a flag which can be then used to cause an interrupt.  The interrupt service routine then needs to check each row and column - but this is really fast and does not need to be done very often (relative to a 2.7MHz 6502!), so a whole key scan is not done any more often than 0.05 of a second (3 vertical blank intervals).<br></p><strong>Video</strong><p>One thing I have observed with many homebrews is the lack of video output - they get by with serial I/O only or interfacing to hex LED or dot matrix LCD panels.  This would not be enough for my needs, as I wanted something which would be able to drive a TV, ideally with graphics capabilities to render simple games.</p><p>A reason for lack of video on many homebrews is that old graphic chips are hard to design for (at least for someone of my low level of expertise) and hard to come by.  Modern graphics chips are way too complex to be able to interface to my homebrew - and totally would dilute the 80s feel that I was after.</p><p>I looked at a number of options.  One of the early options was to 'bit bang' video!  Yes, I calculated that if I drove the 6502 at 8MHz, I could probably drive a display with about 176 pixels horizontal resolution.  Anyway, I didn't spend too much time on it - the cycle counting was critical and even if the display did work, there was absolutely no room for future expansion (e.g. colour, sprites, resolution).  I was partly inspired by Quinn Dunki (see <a href="http://quinndunki.com/blondihacks/?p=955">http://quinndunki.com/blondihacks/?p=955</a>) - although she was using an ATmega and outputting VGA, so it was a much more sophisticated bit bang solution than mine.  So, due to effort vs limited reward, I ditched that approach [Edit - there are cleverer ways to use the 6502 address lines to generate video signals, but would have required additional logic which I never considered and got too complicated to generate colour etc.]</p><p>Next, I looked at 6845 chips.  These were used in a few popular computers in the 80s including the BBC Micro and Amstrad CPC.  A highly configurable chip, but it still needed a bunch of supporting electronics (character ROMs and additional custom logic for colour) - it just looked too complicated for someone of my limited experience.</p><p>So finally, I settled on the Texas Instruments 99xx VDP, as used in the MSX computers of the early to mid 80s.  I acquired both the TMS9918 and TMS9928a - almost pin compatible but the '28 produced component video whereas the '18 provides composite.  These are great graphics chips for their era (late 70s) - however the integrated nature comes with a big con.  They are design with the assumption that they connect to DRAM.  As I mentioned before, DRAM is a pain and hard to get hold of - and it was one of the reasons why I was originally put off by using the TMS99xx.  But there are so many clever people willing to share their knowledge, and I found a resource on the web to adapt SRAM for use with TMS99xx VDPs - a fantastic write up by Tom LeMense entitled "SRAM Replacement for TMS99x8 VRAM".</p><p><strong>Sound</strong></p><p>I have added an AY-3-8910 made by General Instruments for sound.  This is another nostalgic chip for me as it made an appearance in my first home computer, the Oric-1.  I've described more about it in the sound blog.  I will use the 10 input/output lines to add 2 joysticks (each joystick needs 4 direction signals plus the fire button).</p></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/5789/log/18038-hardware-design">Hardware Design</a></h2>
                            <small class="authorship">3 months ago  &bull;
                                <a class="gray-link" href="/project/5789/log/18038#discussion-list">
                                    0 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-18038"><p>In terms of hardware design, I realised that there are not really that many parameters one can play with when using off the shelf components.  The point is that things like the 6502, 6525, 9918 etc. are by design expecting certain inputs and outputs, so they set out some fundamental design constaints.</p><p>The general input, output and interfacing capabilities provided by the 6526s (two of them) and the memory map design are the two most significant areas for creativity.</p><p><strong>Memory Map</strong></p><p><strong></strong>The memory map was one of the first and most interesting areas of investigation.  The 6502 has a 64KB address range - so all my RAM, ROM and memory-mapped devices need to fit in to that.  Being old-school, I wanted to try and put together a map which maximised RAM without overly compromising ROM and memory-mapped device access.</p><p>In the very early incarnations of the homebrew, copied the simplest address decoding approaches I found in other designs:</p><ul><li>If A15 is zero, then select RAM</li><li>If A15 is one and A14 is one then select ROM</li><li>if A15 is one and A14  is zero then select devices</li></ul><p>So this gives 32KB RAM, 16KB ROM and 16KB devices space.  I had a board working with this configuration, but it was just to allow me to prove I had wired things up.</p><p>I went for an addressing scheme which would give me 44KB RAM, 4KB devices (8 512 byte IO blocks) and 16KB ROM.  It was fun coming up with the decoding logic for this and then working out how to implement this using some NAND and NOT gates.</p><table><tbody><tr><td><strong>Section</strong></td><td><strong>Type</strong></td><td><strong>Address Range</strong></td><td><strong>Decode rule A15-A12 (binary)</strong><br></td></tr><tr><td>A</td><td>ROM</td><td>0xc000 - 0xffff</td><td>Between 1111 - 1100</td></tr><tr><td>B</td><td>IO Blocks</td><td>0xb000 - 0xbfff</td><td>1011 only</td></tr><tr><td>C</td><td>RAM</td><td>0x0000 - 0xafff</td><td>Between 1010 - 0000</td></tr></tbody></table>The decoding of these address line (A15 to A12 for the section select, A11 to A09 for the IO block select) needs also to take in to account the chip select lines available.  Doing this would hopefully reduce the complexity of the decoding a little.  I am using a W27C512 for ROM, 628128 for RAM and a 74xx138 3 to 8 decoder for the IO block select.  These chips have the following select lines:<ul><li>ROM : /CE, /OE</li><li>IO BLOCK (74xx138) : /E1, /E2, E3</li><li>RAM : /CS1, CS2</li></ul><p>In addition to the A15-A12 lines, the additional signals are also needed from the 6502:</p><ul><li>PHI2 (this is high when the 6502 has control of the data and address lines)</li><li>R/W (this is high when performing a read, else it is a write)</li></ul><p>The analysis I did resulted in the following table, which showed that I need 3 NOT and 6 NAND gates to implement the decode (plus the direct use of A14 which doesn't need a gate).  I am sure someone can do better than, this but hey this is is my first custom memory map decoder, and it seems to work, so I'm happy - but any suggestions would be interesting.</p><table><tbody><tr><td><strong>Gate #</strong></td><td><strong>Type</strong></td><td><strong>Input A</strong></td><td><strong>Input B</strong></td><td><strong>Output</strong></td></tr><tr><td><strong></strong>1</td><td>NAND</td><td>Phi2</td><td>A15</td><td>ROM /OE,  IO /E1<br></td></tr><tr><td>2</td><td>NOT</td><td>A14</td><td></td><td><br></td></tr><tr><td>3</td><td>NAND</td><td>A13</td><td>A12</td><td></td></tr><tr><td>4</td><td>NOT</td><td>Gate #3</td><td></td><td>IO E3</td></tr><tr><td>5</td><td>NAND</td><td>A15</td><td>A14</td><td><br></td></tr><tr><td>6</td><td>NAND</td><td>Phi2</td><td>Gate #5</td><td>RAM /CS1</td></tr><tr><td>7</td><td>NAND</td><td>A15</td><td>Gate #2</td><td></td></tr><tr><td>8</td><td>NOT</td><td>Gate #7</td><td></td><td></td></tr><tr><td>9</td><td>NAND</td><td>Gate #8</td><td>Gate #4</td><td>RAM CS2</td></tr><tr><td>10</td><td>NAND</td><td>A14</td><td>R/W</td><td>ROM /CE</td></tr></tbody></table><p>In addition, A14 feeds directly to /E2 for the IO decoder, and in addition to the chip select lines for RAM, the 6502 R/W line feeds directly to the /WE line (i.e. low for write, high for read).<br><strong></strong></p><p><strong>Device Selection</strong><br></p><p>As mentioned, the /E1, E2 and E3 outputs enable the 74xx138 decoder.  This basically then takes A11, A10, A09 as inputs and selects one of 8 outputs (active low).  So therefore I have 8 addressiable devices I can select.  This should be plenty, as I can't think of more than 8 different devices:</p><ul><li>Block 0 : 1st 6526 CIA</li><li>Block 1 : 2nd 6526 CIA</li><li>Block 2 : TMS9918 VDP</li><li>Block 3 : AY-3-8910 Sound (planned - subject to further design and datasheet review)</li><li>Block 4 : 6551 ACIA (planned - low priority as I already have functional serial I/O)</li></ul><p>In fact, looking at the AY-3-8910, I don't think this this is going to be directly accessible due to the very long strobe and hold times that the datasheet is specifying.  So this will likely be through on of the 6526s (e.g. all of port A for data transfer, some lines from port B to control access).</p><br></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/5789/log/18039-software-design">Software Design</a></h2>
                            <small class="authorship">3 months ago  &bull;
                                <a class="gray-link" href="/project/5789/log/18039#discussion-list">
                                    0 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-18039"><p><strong>Monitor</strong></p><p><strong></strong>I have built a really simple monitor program, supporting the following commands</p><table><tbody><tr><td>Command</td><td>Description</td><td>Format   </td></tr><tr><td>Q</td><td>Quit the monitor.  Has little effect as there are no other programs to run!</td><td>Q</td></tr><tr><td>M</td><td>Set the memory type to normal RAM (R) or VRAM (V).  This is of course because my homebrew has separate CPU and VDP memory spaces.  In actuality the command only looks the the 'V', anything else signifies not V.</td><td>M [V|R]</td></tr><tr><td>A</td><td>Set the address to the hex address specified by xxxx.  The address will apply to the current memory type. E.g.<br>A 1000<br>The above will set the address to hex 1000, for the current memory type.<br></td><td>A xxxx</td></tr><tr><td>D</td><td>Dump 8 bytes of the current address, advance the address by 8 bytes.  The address will apply to the current memory type.  The dump looks like this:<br>xxxx xx xx xx xx xx xx xx xx<br>The command then waits for input - if enter (CR) is received, then the next 8 bytes are dumped.  Else the command exits back to the monitor prompt.<br></td><td>D</td></tr><tr><td>S</td><td>Store bytes at the current address, advance the address by the number of bytes stores.  The bytes will be stored to the current memory type.  E.g.<br>S 01 02 03<br>The above input will store the hex values 01, 02, 03 in 3 consecutive memory locations.<br></td><td>S xx[xx]*</td></tr><tr><td>R</td><td>Run from location xxxx.  This always refers to the CPU memory space as the CPU cannot execute code in VRAM.  E.g.<br>R 1000<br>The above transfers control to the program at memory location hex 1000, after saving P, A, X and Y.  The program should complete with an RTS instruction to hand control back to the monitor.<br></td><td></td></tr></tbody></table></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/5789/log/18416-serial-communications">Serial Communications</a></h2>
                            <small class="authorship">3 months ago  &bull;
                                <a class="gray-link" href="/project/5789/log/18416#discussion-list">
                                    2 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-18416"><p><strong></strong></p><strong><p>Serial Input / Output</p></strong>One of the key methods of input and output with my home brew is serial communications to and from my development machine (a modern Windows 7 laptop).<p>The serial commmunication protocols I remember from in the 80s and early 90s was RS-232.  I naively thought this would be the thing to use now.  However, my development machine does not have serial ports - USB is now the only serial methods I have at my disposal.</p><p>A bit of research revealed that direct USB to homebrew connectivity would be difficult (at least for me) to achieve.  However, the popularity of kit like Arduino and Raspberry Pi have helped the proliferation of USB to serial cables with built in adapters.  I purchased a very cheap one off ebay.  It means that when connected to my dev machine, an additional COM port in Windows is available, through which I can use a terminal emulator.  On the homebrew side, the cable presents 4 pins : +5V, GND, Serial Out, Serial In.  This means I also have the ability to power my homebrew off the 5V supply rather than using my home-made 5V supply (interesting mini-project, but clunky).<br></p><p>My original serial comms was designed around using the SP pin on each of the two CIAs for input and output.  However, it required a fairly software intensive set up to drive and I wasn't happy with the reliability of it.  Plus, I wanted to use the CIA lines for other expansion options.</p><p>So I added a MOS6551 ACIA.  This is a fairly simple to operate serial input/output device, and being part of the MOS family, easy to interface to the 6502.  I will keep the rest of this section for historic purposes.</p><p>The software programming of the CIA was simple and it was easy to update the few low level I/O routines.  However, it still took me ages to get it working because the ACIA needs a 1.8432Mhz clock.  As this is not a muliple of my 21.7MHz, it needed it's own clock circuit.</p><p>So I obtained an appropriate crystal and wired up a 7404 using a circuit diagram off the internet.  I checked it with the scope and it looked like the circuit was putting out a clean 1.8432MHz square wave.  However the ACIA was not working, no matter what I did.  I then noticed some unusual behaviour - for example if my finger touched the crystal, suddenly the ACIA would work and continue to work.  Even putting my hand near the ACIA seemed to kick it in to life - very, very weird.</p><p>I put it down to the clock generator circuit.  I have not spent any time trying to understand the most analogue part of the home brew which is the clock generators using piezo effects generated by crystals.  So I had no idea what to do, but after further searching found an alternative circuit which starts up without requiring the touch of a finger or a magic wave of the hand!!<br></p><p><strong>Old CIA based Serial</strong><br></p><p>The two 6526 CIAs in the system provide serial communications. Even though each CIA has a SP pin for serial input or output, the USB to serial adapter I am using has a dedicated pins for send and receive. I wasn't sure how to wire up a single SP to two pins on the serial interface, so I decided to use one 6525 for input and the other for output.</p><p><strong>Serial Input</strong></p><p><strong></strong>I started with designing serial input.  The mode of operation is as follows:</p><ul><li>Set up the CIA so that PB6 acts as a clock, running at Timer A underflow speed and the SP pin is configured for input</li><li>Connect PB6 to the CNT line which provides the clock for sampling the serial input line</li><li>Connect the /FLAG pin to the Serial input line.  This means I an configure an interrupt to occur if the serial line goes low.  The default state of the serial input line is high, with a zero start-bit indicating the start of a transfer.</li></ul><p>The software to run this is fairly simple.  In pseudo code it looks like this:</p><ul><li>Wait for /FLAG to go low (this can be through an interrupt or polling the CIA ICR)</li><li>Wait 1/2 a bit time - this is to try and sample in the middle of a serial bit</li><li>Initialise Timer A to 1/2 the bit time required and start in continuous mode, PB6 to toggle Timer A underflow.  At this point the CIA is starts shifting serial data on the SP pin in to the SDR</li><li>Monitor the ICR to indicate SP (meaning that the SDR now has 8 bits of data).</li><li>Read the SDR - et voila, this is your received byte.</li></ul><p>One slight complication - the CIA expects data to be shifted in from MSB to LSB (i.e. shifting right each time).  It turns out the USB to serial adapter does it the other way.  So the final step is to shift the SDR LSB first in to the translated byte MSB first.</p><p>The Timer A countdown is clocked by Phi2, which is 2,684,659Hz.  This means one clock cycle is approximately 0.3725 of a microsecond.  To clock serial data in at 9600 baud (bits per second) means that each bit is approximately 104 microseconds.  Half a bit time is 52 microseconds.  Therefore Timer A needs to be set to 140 (52/0.3725, rounded to the nearest whole).</p><p><strong>Serial Output</strong></p><p><strong></strong>Output is done on the second CIA, and the mode of operation is even simpler than input:</p><ul><li>Set up the CIA so that the SP pin is in output mode, with Timer A set up for 1/2 the bit time</li><li>Write to the SDR (first translate the byte to be sent as due to the MSB vs LSB shift order)</li><li>Monitor the ICR SP flag until the CIA indicates the data has been shifted out</li></ul></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/5789/log/18434-video-output">Video Output</a></h2>
                            <small class="authorship">3 months ago  &bull;
                                <a class="gray-link" href="/project/5789/log/18434#discussion-list">
                                    7 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-18434"><p>As I have previously mentioned, I really needed to have video output for my homebrew that was 80s in style and capability.  I poured over a number of options including:</p><ul><li>6845 as per BBC Micro, Amstrad CPC</li><li>6847 as per Dragon 32</li><li>Self generated as per ZX80!</li></ul><p>The 6845 and 47 to me seemed daunting as my knowledge of digital hardware is so basic, so I discounted those.</p><p>I did a fair bit of research in to self generated video - partly inspired by Quinn Dunki&apos;s attempt using an AVR.  However I didn&apos;t have an AVR so was going to use a second W65c02s running at 8MHz - I calculated that I could just about generate a 176 pixel monochrome display if I was very careful with instruction cycle counting.  However, I was not sure about the ability to generate the synchronisation signals as this would need something like a 6522 or 6526 and they may not be able to keep up with the display processor.  Anyway, to cut a long story short, I decided this option had too many unknowns and I could end up spending a lot of time building something which would not work or ever be expandable.</p><p>In my search I did keep going back to the TMS99xx series of Video Display Processors.  These were commonly found in the TI99-4/A and MSX range of micros in the 80s, although Colecovision and other consoles also used it IIRC.</p><p>The great thing about this VDP is that it as separate video memory, which means my main computer has more to RAM to play with.  Also, it has some pretty good features considering it was made in the late 70s including up to 32 sprites, 15 colours and multiple display modes (32x24 column text, 40x24 column text, 64x48 multicolour low res graphics).  The 9918 (which I am using) doesn&apos;t have the bitmap graphics mode to give pixel level access to a 256x192 grid - if I want this then I could use the 9928a or source a 9918a. </p><p>However the TMS99XX series does have some pretty big draw backs.  The main one is the fact it is designed to work with DRAMs, which are very hard to get hold of and very fiddly to wire up.  The second at the time seemingly minor irritation was the need for a precise 10.738635Mhz crystal.</p><p><strong>SRAM replacement for DRAM</strong><br></p><p>The DRAM problem is significant because they are usually accessed very differently to SRAM.  Typically an SRAM will have all the address lines required to select an address for reading or writing.  A DRAM has RAS and CAS signals which select the row, and then the column - i.e. it is not done in one bus access cycle.  The solution to this is something I would never have been able to figure out myself, but basically the RAS and CAS addresses need to be latched so that the full address can be assembled before sending on to the SRAM.  The details about how to do this are on the web - in particular an article by <span class="st"><em>Tom LeMense</em> entitled &quot;<em>SRAM</em> Replacement for TMS99x8 VRAM&quot;</span>.  A quick note about this article though - I downloaded it a few months ago fine, but searching for it now appears to need one to register with <a href="mailto:n8vem@googlegroups.com" target="_blank">n8vem@googlegroups.com</a>.</p><p>The implementation principles are as follows:</p><ul><li>Typical SRAMs have the following control lines:<ul><li>14 (A0..A13), 15 (A0..A14) or 16 (A0..A15) address lines depending on whether the chip is 16KB, 32KB or 64KB in size.  I use a 32KB chip so have lines A0..A14.  However the TMS99xx will only need to assert lines A0..A13, so any additional address lines should be hardwired to ground.</li><li>IO0..IO7 data lines, which are in input mode for write, and output mode for read depending on the three control signals below</li><li>Chip select (CS) - active low.  Only when this line is low will the SRAM accept any other control and data signals</li><li>Write enable (WE) - active low.  When this line is low, the SRAM will be in write mode (assuming CS is low).  The SRAM will take data on IO0..IO7 and write it to the address on A0..A13</li><li>Output enable (OE) - active low.  When this line is low *and* WE is high the SRAM will be in read mode (assuming CS is low).  The SRAM will output on IO0..IO7 the contents of the memory location defined by A0..13</li></ul></li><li>The TMS99xx is designed for DRAMs of the time, which had separate lines for read and write as well as lines for address, write, row address and column address.  The signals and lines are thus:<ul><li>AD0..AD7 lines are to present, row, column and data to be written to ram</li><li>RD0..RD7 lines to read from ram</li><li>RAS, CAS when row and column addresses are present on AD0..AD7</li><li>RW to indicate when data to be written is present on AD0..AD7</li></ul></li><li>A write sequence is as follows (as shown in the datasheet):<ul><li>The AD0..7 lines are first set to the row address, and the RAS line goes low to indicate the row address is valid</li><li>The AD0..7 lines are then set to the column address, and the CAS line goes low to indicate the column address is valid (RAS stays low)</li><li>The AD0..7 lines are then set to the data to write, and the RW line goes low to indicate the data is valid to write (CAS stays low)</li><li>At the end of the sequence, RW goes high, then CAS then RAS.</li></ul></li><li>A read sequence is similar to above, except that the RW line stays high, and any data read from ram is presented to the RD0..RD7 lines.  To enable this, wire IO0..IO7 directly to RD0..RD7.</li><li>Two 74xx574 latches are needed to capture the AD0..7 lines during the row and column sequence, an additional 74xx574 to capture the AD0..7 for data to be written.  Let&apos;s call them Latch A, B, C<ul><li>For all latches, connect the AD0..7 to the D1..8 lines, noting that the TI convention is that AD0 is the MSB and AD7 is the LSB.</li><li>For each latch to capture data presented on its D1..8 lines, the CLK line needs to go from low to high</li><li>For each latch to output the latched data on its Q1..8 lines, the OE line need to go low (the latch will output as long as the OE line is low).</li></ul></li><li>For latch A, which will capture the row component of the address:<ul><li>Feed the TMS99xx RAS line through a NOT gate to Latch A CLK line.  The reason for the NOT is because CLK is active high whereas RAS is active low.</li><li>Wire the Q2..8 lines to A0..A6 of the SRAM.  Q1 is the MSB and not required as the TMS will output 7 lines of row and 7 lines of column address.</li><li>Hardwire the OE line to ground, to effectively always enable this latch</li></ul></li><li>For latch B, which will capture the column component of the address:<ul><li>Feed the TMS99xx CAS line through a NOT gate to invert the signal.  Then feed the inverted through *two* more NOT gates before connecting to the CLK line.  This is to provide a small delay between CAS going low, and the data on AD0..AD7 being stable before being latched.</li><li>Wire the Q2..8 lines to A7..A13 of the SRAM (the TMS doesn&apos;t use AD0 which is the MSB).  Any additional SRAM address lines should be wired to ground (the TMS99xx only used 16KB i.e. 14 address lines in total)</li><li>Hardwire the OE line to ground, to effectively always enable this latch</li></ul></li><li>For latch C (only used for write operations):<ul><li>Invert the RW line through a NOT and feed to the CLK line, to cause the latch to trigger when there is a low to high transition.</li><li>Wire the Q1..8 lines to IO7..IO0 of the SRAM so that data to be written from the TMS99xx is presented to the SRAM.  The thing to make sure here is that the wiring from AD0..AD7-&gt;D1..D8-&gt;Q1-&gt;Q8-&gt;RD0-&gt;RD7 is consistent i.e. there is a path from ADx to RDx.  Also, remember this ordering when wiring up the CD0..CD7 lines to the CPU, noting that the LSB is bit 7 and the MSB is bit 0 in TI convention.</li><li>Connect the RW line directly to the OE line so that the latch is only outputting when RW is low (i.e. when there is a write operation being done by the TMS99xx)</li></ul></li><li>This is pretty much it, except we need to make sure the SRAM is only accepting signals and doing the right operation as follows:<ul><li>Connect the SRAM OE to the inverted RW signal i.e. OE will be active low if in read mode</li><li>Connect the SRAM WE directly to the RW signal i.e. WE will be active low in write mode</li><li>Connect the SRAM CS directly to the CAS signal i.e. SRAM will be active once the row and column addresses have been presented.</li></ul></li><li>So simply, what all this does for a write is:<ul><li>TMS puts row address on AD0..AD7</li><li>TMS puts RAS low</li><li>Latch A captures AD0..AD7</li><li>TMS puts column address on AD0..AD7</li><li>TMS puts CAS low</li><li>Latch B captures AD0..AD7</li><li>TMS puts data on AD0..AD7</li><li>TMS puts RW low</li><li>Latch C captures AD0..AD7</li><li>SRAM is active due to CAS being low and in write mode.  Latch outputs A and B form the address and latch C output forms the data to be written</li></ul></li><li>For a read, the final three steps above are not undertaken.  SRAM is active due to CAS being low and in read mode.  SRAM IO0..IO7 data is output to the TMS.</li></ul><p><strong>TMS9918</strong><br></p><p>I acquired a TMS9918 from ebay and infact also have a TMS9929a.  They are almost pin compatible, with some key differences in the video output - the 9918 puts out composite whereas the 9929 puts out component video.</p><p>Some key features of the this VDP are as follows:</p><ul><li>The clock input consists of XTAL1 and XTAL2 - which need to be out of phase with each other and at 10.738635MHz.  This is achived by feeding the 10.7Mhz clock in to a NAND gate to get the inverse.  I could have used a NOT gate, but have more 74xx00 chips than 74xx04.</li><li>The chip select lines are /CSR and /CSW.  Both high means the VDP is not selected.  Only one of /CSR or /CSW can be low at any time.  This is achieved by feeding the IO2 output of the decoder and the 6502 R/W line through NAND gates to get the required select states.</li><li>The MODE line selects command or data access to the VDP.  As the 6502 is memory mapped, the A0 line is used to select MODE.  The effect of this is that the 6502 selects the VDP by accessing memory locationd 0xB400 and 0xB401</li></ul><p>There are a number of other small quirks and considerations, but the above are the main ones, aside from the SRAM circuitry, which also complex (for my brain), is still less cumbersome than using DRAMs.</p></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/5789/log/19481-sound">Sound</a></h2>
                            <small class="authorship">2 months ago  &bull;
                                <a class="gray-link" href="/project/5789/log/19481#discussion-list">
                                    0 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-19481"><p>For my homebrew to have a reasonably complete set of features, I really want some sound output capability.  For the retro and nostalgic feel, I chose the AY-3-8910.  This is a common sound part from the 80s, and was the sound chip in my very first computer, the Oric-1.  It was also used in MSX and some other 80s devices (even in PC sound cards and arcade machines iirc).</p><p>Wiring up an 8910 is fairly straightforward, however it cannot be driven directly off the 6502 address and data bus.  The reason is that the 8910 has some bus control lines which are more compatible with the processor family that General Instrument (makers of this part) also used to produce.</p><p>To drive the 2 lines (BDIR, BC1), I have to use some lines from the second 6526.  In addition, the data lines also need to be driven off the 6526.  This is annoying, because I am having to use 10 of my 16 data lines just to drive the 8910.  Also, this is really slow, for example a write sequence looks like this (assuming that X contains the 8910 register to write a value contained in Y:</p><ul><li>Set Port A (this port is connected to the to the 8910 data bus) to output</li><li>Write X to Port A (this puts the register address on to the 8910 data bus)</li><li>Set Port B bit 0 and 1 (these bits are connected to BDIR and BC1 on the 8910) to latch register mode</li><li>Zero the Port B bits to enable the next command</li><li>Write Y to Port A (this is the value we want to set the appropriate register to)</li><li>Set Port B bits to write mode to effect the transfer in to the 8910 register</li><li>Zero the Port B bits ready for the next command</li></ul><p>So this is a lot of writes just to set a register in the 8910.  And several registers need to be set to be able to make a sound!  But I have tiny sense of personal achievement that I'm understanding the challenges that the engineers at Tangerine had when they designed the Oric-1 (similar solution).</p><p>One useful thing the 8910 does have 16 I/O ports, so that kind of makes up for having to use the 6526 ports to drive it - although getting data in and out of these ports is slow.</p><p>However, these I/O lines will be good for human interface devices as they are much slower than serial or video access.  Hence, I am using the port for the 80's Atari compatible joysticks.  These need 5 lines (4 directions plus fire button), so I could add more than one joystick (might be useful).  For the moment I have stuck with 1 joystick only, as I may need lines to drive a keyboard.</p></div>
                            </div>
                        </li>
                    
                </ul>

                

                

                </p>

            
        </div>
    </div>

    










<div class="footer" id="footer">
  <a href="#header" class="back-to-top" onClick="CT(this, 'Footer', 'GoingUp');">^ Going up? ^</a>
    <div class="container">
        <p><a href="http://hackaday.com/about/">About Us</a> <a href="mailto:projects-contact@hackaday.com">Contact Us</a> <a href="/project/37">Give Feedback</a>&copy; 2015 Hackaday <a href="/tos">Terms of Use</a> <a href="/privacy-policy">Privacy Policy</a></p>
        <a href="/" class="had-skull"  onClick="CT(this, 'Footer', 'Home' ); return false;">Hackaday.io</a>
    </div>
</div>

<script>

    var csrftoken = 'Rnegwyou-0ifxbwNIhPJeL0PWvyt1b0t--r0';

</script>

    <script type="text/javascript">

    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-47229708-1', 'auto');

    var dimensionValue = 'nonregistered';
    ga('set', 'dimension1', dimensionValue);
    ga('require', 'displayfeatures');

    ga('send', 'pageview');

    </script>

<img src="//analytics.supplyframe.com/trackingservlet/impression?action=pageImpression&amp;zone=HIO_logs&amp;extra=logged%3Dfalse%7ChaveAccountCookie%3D0%7C&amp;ab=undefined" class="sf-impression" />

    
    
    <script src="//cdn.hackaday.io/build/h%2FydgsYIeDTf7pqgYQEKK8Ngblw0IkZCDqfJ9S2tk7zsBoxIHt5iOd49Qp%2BF4vdxEuRj%2BGpGDLbX4aGOQGmbjaOxUZvklg4ReFk68R95OQshFrGKebvogKGQOiB5Hi1xym9KC54c9Ps0WpzuNydLk4B%2FbKi91KhV40Uxhl38XXb1IVAxAI8iW%2BoQUPCFkHVWZxD0B%2BMZ%2BuEXJTlWuBmopNMxTHRK5yleITPZODT6evbVRQc6AXs9w2Pfk7FS2nKy-0.48.6.js"></script>

</body>
</html>