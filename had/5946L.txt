<!doctype html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->
<!--[if IE 9]>    <html class="no-js ie9" lang="en"> <![endif]-->
<!--[if gt IE 9]><!--> <html class="no-js" lang="en" ng-app="buildlogApp"> <!--<![endif]-->
<head>
    
    <title>Project logs &bull; OpenCT2 &bull; Hackaday.io</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="//cdn.hackaday.io/css/style.css?version=0.48.6" />
    <script type="text/javascript" src="//use.typekit.net/ymb0lgk.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
</head>
<body class="logs">

    <!--
############################################################################################
############################################################################################
############################################################################################
#####################Kt;tL#######################################Kti,E######################
#######################;   .###################################G    E#######################
#######################K    f##################################    ;########################
########################Wj   E###############################K:  .W#########################
##########################.  :E##############################:  .L##########################
#########################D    f##############################.   .##########################
########################,     ;##############################     :E#######K################
################f######K      ,##############################      ,######Lt################
################  W###W       i##############################       t####j t################
################:  E#L.        f###########################L.        f#Ki .E################
################j  ;E.          j##########################.         .G;  i#################
#################L               i#######################K                ##################
#################W                E#####################K;               ;##################
###################:               .###################D               :f###################
#####################DLfGD           G####WEEEEKW####W           ;GffGK#####################
##########################i         iD##Kfi    :jKW##D          iE##########################
###########################W      ,G##f            jE#E;       j############################
############################L     D##D              ,##K       W############################
#############################D:  G#W                  K#E,   G##############################
###############################;i#L                    j## ,E###############################
###############################KK#.                     ##iE################################
#################################j                      ;K##################################
################################W                        ,##################################
################################E                         ##################################
###############################Ki                         D#################################
###############################E.                         L#################################
###############################f    iD##W;       D###D    :#################################
###############################i   i######K     K#####K;   #################################
###############################;  .E#######     #######D   #################################
###############################;  L########     ########   #################################
###############################i  G#######K     K#######   #################################
###############################j  L#####E,       fE#####   #################################
###############################D  .E##j            .t##E  ;#################################
###############################E:  ;##.              #Wt  j#################################
################################G   ;t      tWi      t    E#################################
#############################KL##           K#K;          #K:K##############################
#############################i ##:          ###t         j#f ;K#############################
############################:  G#K          #E#L        L##    D############################
###########################D   ;W#:         #;#L        W#K    .############################
#####################KKEKK      :##L        ; ..      :D##.      fKEEK######################
###################t.            ;##G:               ,##E,             tD###################
##################G               E##E               i##;               :###################
#################D                W##W    iL    E.    ###D                ##################
################W,               G###W    tG    K.    ####:               K#################
################;  LW;         ,E#####:  ;W#    #G   f#####;         ;KG  :K################
################  D###E       ;########WW####WW####WW#######W       :####: j################
################ ,#####:      ;##############################       G####E i################
################K#######.     ;##############################      L######WG################
########################f     i##############################     j#########################
#########################W   .D##############################.   i##########################
#########################E   G###############################D   ,##########################
########################G:   #################################j   G#########################
#######################f    K##################################j    W#######################
#####################Kt :iE#####################################KL:  K######################
############################################################################################
############################################################################################
############################################################################################
-->

<div class="header" id="header">
    <div class="container">
        <h1 class="logo">
            <a href="/" title="Hackaday.io Home" class="home" onclick="CT(this, 'Menu', 'Home'); return false;"></a>
            <a href="/" title="Hackaday.io Home" class="brand" onclick="CT(this, 'Menu', 'Home'); return false;">Hack a Day</a>
        </h1>

        <a href="javascript:void(0);" class="responsive-menu">Menu</a>

        <ul class="nav" role="navigation">
            <li><a href="/projects" class="">Projects</a></li>
            <li><a href="/lists" class="">Lists</a></li>
            <li><a href="/stack" class="">Stack</a></li>
            <li class="dropdown more-nav j-more-open">
                <a href="javascript:void(0)" class="dropdown-link icon-dropdown">More</a>
                <ul role="menu" class="dropdown-menu more-menu" id="j-more">
                    <li><a href="http://hackaday.com/blog/" target="_blank">Blog</a></li>
                    <li><a href="/events">Events</a></li>
                    <li><a href="/hackerspaces">Hackerspaces</a></li>
                    <li><a href="/hackers">Profiles</a></li>
                    <li><a href="/contests">Contests</a></li>
                    <li><a href="/prize" target="_blank">The Hackaday Prize</a></li>
                    <li><a href="/submissions/prize2015/list">2015 Prize Entries</a></li>
                </ul>
            </li>
            <li class="menu-last-child">
                <div class="search-holder show">
                    <form id="search-form" action="/search" onsubmit="return submitSearch();" method="GET">
                        <input type="text" placeholder="Search" name="term" class="input-search j-add-search" id="j-add-search" value="" autocomplete="off" pattern=".{3,}" required title="3 characters minimum" />
                        <input type="submit" class="search-button" />
                    </form>
                </div>
            </li>
        </ul>

        

            <ul class="nav pull-right" role="navigation">
                <li><a href="/signup" class="grey-white-button become-member">Sign up</a></li>
                <li><a href="/signin?returnUrl=%2Fproject%2F5946%2Flogs">Sign in</a></li>
            </ul>

        
    </div>
</div>

<div id="topMessage" class="alert"><span class="j-top-content"></span><a href="javascript:void(0);" class="alert-close j-top-message-close">Close</a></div>




    <div class="headline">
        <div class="container">
            <h2><a href="/project/5946-openct2">OpenCT2</a></h2>
            <p class="description-title"> Project logs</p>
            <p class="description-summary">An open source low-resolution desktop CT scanner</p>
            <div class="description-metainfo">
                
                    <span>created by <a href="/hacker/11110-peter-jansen" title="Visit Profile">peter jansen</a><span>&bull;</span>
                
                3 months ago<span>&bull;</span><a href="/project/5946#discussion-list" title="See Comments">10 Comments</a></span>
            </div>
        </div>
    </div>

    <div class="container post-content">
        <div class="section-buildsort">
            <span class="pull-left">
                <a href="/project/5946-openct2">&#171; Back to project details</a>
            </span>
            <span class="sort-holder pull-right">
                <label for="sort-by">Sort by:</label>
                <select class="sort" id="sort-by">
                    <option value="/project/5946/logs/sort/newest">Newest</option>
                    <option value="/project/5946/logs/sort/oldest" selected="selected">Oldest</option>
                </select>
            </span>
        </div>
        <div class="section section-buildlogs last">
            

                <ul class="buillogs-list">
                    
                        <li>
                            <h2><a href="/project/5946/log/18391-developing-a-parallel-detector-for-an-open-source-ct-2">Developing a parallel detector for an Open Source CT 2</a></h2>
                            <small class="authorship">3 months ago  &bull;
                                <a class="gray-link" href="/project/5946/log/18391#discussion-list">
                                    3 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-18391"><p>I've been thinking about tomographic imaging a lot lately in between nursing sore fingers from learning how to hand-wind electromagnetic coils for my attempt at a small prepolarized coded-field MRI, and I thought I'd take a moment to share some progress.</p><p><img src="https://cdn.hackaday.io/images/4421531432414683006.jpg"></p><p>The open source computed tomography (CT) scanner that I put together last year was a lot of fun to design, having many atypical design problems in it, from the mechanical design of the rotary gantry to pairing an appropriate radioisotope source with a modified extra-sensitive radiation sensor. Something about it being essentially a radioactive desktop Stargate that lets you see inside of things also seems to get people very excited, and so I've received an eclectic bunch of e-mails asking about the scanner from folks as diverse as radiology professors and biomedical folks to makers to those hoping I'd open up Dr. Jansen's back-alley CT scans to have a look at some strange bump they have (please go see your doctor!). But I feel that for all the excitement, to quote <a href="http://en.wikipedia.org/wiki/Surely_You%27re_Joking,_Mr._Feynman!">Feynman</a>, the current open CT design feels a bit like a dog that walks on two legs — it's not that it does it <i>well</i>, it's that it does it at all. It's essentially a working model of the <a href="http://clinical.netforum.healthcare.philips.com/global/Explore/White-Papers/CT/Development-of-CT-imaging">first generation of CT scanners</a>, and so it takes a very long time to get even a single slice of an image. I've been wondering what it would take to move it from a proof of concept into something that does the job well, or at least substantially better.<br></p><p><img src="https://cdn.hackaday.io/images/2372161432415458265.jpg"></p><p>The previous design makes use of a 10uCi Barium-133 radioisotope check source, which is the strongest radioisotope source that's available without a licence. Barium-133 has strong x-ray peaks around 31kEv and 81kEv, which are low enough energy that organic water-containing materials (like apples and bell peppers) are reasonably contrastive for imaging. The silicon PIN photodiode detector in the <a href="http://www.radiation-watch.org/p/english.html">Radiation Watch</a> Type 5 high energy particle detector that I used is also most efficient at low (~10kEv) energies, meaning that we would need less exposure time to generate an image with sufficient signal to make things out, although there are <a href="http://www.tricorderproject.org/blog/dr-jansen-or-how-i-stopped-worrying-and-learned-to-love-the-barium/">technical challenges</a> in detecting these lower energy photons. Imaging under these circumstances is essentially a constant battle for detecting signal over the noise, and one way to generally increase SNR is to increase the measurement time — although of course this increases how long it takes to create an image. In the extreme case when you're so signal starved, it ends up taking all night just to capture a single slice of a bell pepper.<br></p><p><img src="https://cdn.hackaday.io/images/3315931432415473360.jpg"></p><p>Another alternative that's been suggested is to increase the intensity of the x-ray source. For a variety of safety reasons this isn't something that I'm willing to explore. I've heard of folks experimenting with surplus x-ray tubes and equipment, and I believe that your health is just too precious to risk for such endeavors. Pragmatically, as an open source project, using readily available radioisotope check sources is also much more repeatable than found radiography parts.</p><p>And so we're left with a few alternatives:</p><ul><li><b>Decrease the scanning volume:</b> The current design has a source-detector distance of about 12cm. Following the inverse square law, each halving of this distance should increase the number of counts at the detector by a factor of 4.</li><li><b>Detect in parallel:</b> Starting with second-generation CT scanners, parallel arrays of detectors were used to dramatically decrease scan time. This should give linear speed gains — e.g. N detectors should reduce the scan time by a factor of N.</li><li><b>Increase sensitivity:</b> Detecting the signal from single photons requires a genuinely incredible amount of amplification, and this process is noisy. While previously recalibrating the Type 5 detection threshold to just above the noise floor yielded many more counts, it appears as though much of the signal is still buried below the noise floor of the detector.</li></ul><p>It's likely that a solution will end up with some combination of each of these alternatives.</p><p><img src="https://cdn.hackaday.io/images/8710421432414730599.jpg"></p><p><b>Parallel Detectors</b><br>Where the first generation of medical CT scanners contained only a single photodetector, I've read that each generation of CT scanner after has increased the number of detectors <a href="http://radiopaedia.org/articles/ct-scanner-evolution">by about an order of magnitude</a> over the generation before it — moving from ~30 detectors in a second generation system, to ~300 in third-generation fan-beam systems, to ~2000 in modern static ring systems. Each of these improvements allowed scan times to reduce accordingly, starting from about half an hour with first generation systems, to about a minute, to now only a few seconds.</p><p>Above we can see how the current system might be parallelized with more Type 5 detectors, each arranged across an arc such that there is a constant distance between the source and each detector. The Type 5 is one of my favorite sensors of recent years, and I've had a lot of milage out of it, but unfortunately because it's about an inch across, it would be difficult to parallelize the desktop CT with more than about 6 detectors using this design. Additionally, the fantastic <a href="http://www.first-sensor.com/cms/upload/datasheets/X100-7_SMD_501401.pdf">First Sensor X100-7</a> that the Type 5 uses has a 10mm x 10mm active area, which makes it great for collecting and detecting high energy particles, but a little large for the kind of spatial imaging that we're doing, so the images will be a little blurred. Having a smaller detection area will increase our spatial resolution, and decrease the detector size — so that (ideally) we'll be able to pack many more detectors in (as shown below), and decrease the scan time.</p><p><img src="https://cdn.hackaday.io/images/3267281432414749851.jpg"></p><p><b>Designing an inexpensive parallel detector</b></p><p>High-energy particle detectors are extremely challenging to design and build, in large part because you're amplifying the signals from a single subatomic particle by many orders of magnitude in order to be barely detectable by a microcontroller. Because of this they're extremely sensitive to noise, layout, component selection, and generally must also be shielded from external interference. Given the design challenge I've been reading whatever I can find on the topic over the last few months, and meditating on layout guidelines to reach the zen-master level of low-noise layout required for such a task, or at least to get a prototype to a point that I can work from.<br></p><p><img src="https://cdn.hackaday.io/images/8677121432414771467.jpg"></p><p>The design that I arrived at (<a href="https://github.com/tricorderproject/openct2/blob/master/hardware/radiationsensor_r0/radiationsensor_r0_schematic.pdf" target="_blank">schematic</a>) is heavily based on the <a href="http://www.maximintegrated.com/en/app-notes/index.mvp/id/2236">Maxim Appnote 2236: Gamma-Photon Radiation Detector</a>, which uses a reverse-biased silicon PIN photodiode as the detector connected to an extremely sensitive first-stage amplifier, followed by a series of cascade amplifiers to increase the signal intensity. The photodiode is the popular <a href="http://www.vishay.com/docs/81521/bpw34.pdf">BPW34</a>, which has been used in a number of other <a href="http://hackaday.com/2014/10/25/use-a-cheap-pin-diode-as-a-geiger-counter/">radiation sensor projects</a>. The active area of the BPW34 is only 7.5mm^2 (a little less than 3mm x 3mm), which is a little over 10 times smaller than the 100mm^2 of the X100-7, so this should increase the spatial resolution a good deal.</p><p><img src="https://cdn.hackaday.io/images/7676001433883332344.jpg"></p><p>While many of the hobbyist designs for radiation sensors operate at effective noise thresholds of around 100keV or more, because here we have such a specialized application where most of the business photons are 31keV or 81keV, keeping the noise floor as low as possible to be able to detect these photons is critical. A number of academic project writeups for radiation detectors I've found suggested that the <a href="http://www.ti.com/product/lmp7721">Texas Instruments LMP7721</a> would be an ideal choice for helping keep the first-stage amplifier as low-noise as possible, both because of its incredibly low noise characteristics (measured in femtoamps), and an uncommon footprint that includes guard pins to further reduce layout noise.<br></p><p><img src="https://cdn.hackaday.io/images/657851432414873506.jpg"></p><p>To make the boards modular and digitally addressable, I've added on a <a href="http://www.microchip.com/wwwproducts/Devices.aspx?product=PIC24F32KA301">PIC24FV32KA301</a> microcontroller, which sports a 12-bit analog-to-digital converter (~1.2mV resolution @ 5V), and plenty of RAM to store a histogram of pulse widths to experiment with doing very crude spectroscopy as I've done with the Radiation Watch Type 5. Both the raw analog output of the photodiode amplifier as well as the digital output of a comparator serve as input to the PIC, and a digipot allows one to dynamically calibrate the comparator output based on the noise level at runtime. I've also included a small LED for debugging.</p><p>The PIC currently exposes an I2C interface (SDA/SCL) for external communication, though in retrospect while this makes communication easy, it would also require programming each detector with a unique I2C address — so future revisions might move to an SPI interface.</p><p>In terms of assembly, the memory of spending 4 days to assemble a set of fine-pitched Arducorder boards is very fresh with me, and so I've designed these to be very easily put together — a single-sided design with 0603 parts or larger on all the passives, and SOIC pitches on each of the ICs with the exception of the SOT-8 footprint for the digipot. So it's comparatively easy to build a bunch of these and pop them in the reflow oven, and with a low-quantity BOM of $20-$30 (about half of which is from the <em><a href="http://www.mouser.com/Search/Refine.aspx?Keyword=LMP7721" target="_blank">TI LMP7721</a></em>), they're relatively inexpensive.<br></p><p><img src="https://cdn.hackaday.io/images/612721432414890556.jpg"></p><p>A series of guard vias on the ground plane divide the analog and digital sections. I've found that shielding the analog section and grounding the shield (like the Type 5) is absolutely essential for operation, much as the appnotes prescribe. I'm not sure what folks tend to use for the shielding tape, but I found that a wrap of electrical tape (to shield the photodiode from light and provide a non-conductive base) followed by a wrap of standard aluminum duct tape from the hardware store seems to work well as a first pass.<br></p><p><img src="https://cdn.hackaday.io/images/7049151432414844021.jpg"></p><p>As an aside, for the low-field MRI project I've been looking for a USB oscilloscope or DAQ that would allow recording at at least 100KSps (ideally 1MSPS) at 12+bits of resolution for several seconds. This is a little unusual — usually scopes that are fast have very short sample memories. I'd seen an article about building a <a href="http://makezine.com/projects/sound-card-oscilloscope/">sound card oscilloscope in Make</a> that would easily allow for such long recordings, as well as folks selling <a href="http://www.virtins.com/P601PC-P601PPC.shtml">oscilloscope probes</a> modified for sound card use, so I thought I'd give this a try before using a benchtop oscilloscope.</p><p>Above is a recording from the sound card oscilloscope with the Ba133 radioisotope source near the detector — and the detections were clearly above the noise floor. Wonderful news! The units on the axes aren't entirely clear here, and with such a slow sample rate we're right on the edge of being able to detect this signal, so on to a benchtop scope to better characterize things.<br></p><p><img src="https://cdn.hackaday.io/images/8520871432414904989.jpg"></p><p>Here I've taped the 10uCi Ba-133 radioisotope source to the side of a 2 inch diameter acrylic cylinder. In this configuration I can easily rotate it to see the number of photons detected when the source is directly beside the detector, and compare this to when the source is 2 inches away, and going through a thin (1/16 inch) acrylic sample container.<br></p><p><img src="https://cdn.hackaday.io/images/4234971432414931542.jpg"></p><p>The noise floor generally appears to be around +/- 40mV, which is very decent for a first try, although it did appear to increase to nearly +/-60mV after being on for a few hours. I was also doing this at <a href="http://www.xerocraft.org/">Xerocraft</a> beside a metal shop, and the noise would periodically go a little crazy when a large piece of equipment (like the mill) was turned on, so I'm not entirely confident in the noise characterization — but it's a good start.<br></p><p><img src="https://cdn.hackaday.io/images/8072221432415763763.jpg"></p><p>The firmware for the PIC isn't complete, so I was using the scope to trigger on the raw analog output instead of using the PIC (either with the analog output, or the digital comparator output). With the Ba133 source very near to the detector there were far too many detections to count, and with it 2 inches away going through the acrylic cylinder, I counted approximately 20-30 counts per minute. That's not incredible, but it's also workable, especially if the noise floor can be lowered, and we gain access to more signal.</p><p>To help ground this, the bell pepper image shown earlier was captured at about 22×22 pixel resolution, with about 60 seconds of integration time per pixel, for a total of about 9 hours of acquisition. Using a parallel array of about 20 of these BPW34 detectors, the rows of such an image could be captured in parallel, so we'd only have to scan in one dimension. Assuming it takes 5 minutes of integration to capture an image with a similar baseline signal (say 100 counts) to 60 seconds of integration with the Type 5, we could capture a similar (likely sharper) image with about 20 measurement cycles using the parallel detector. At 5 minutes per measurement cycle, this would reduce the acquisition time to about 90 minutes, or a factor of 10 faster than the original device. Were we to significantly improve the noise threshold, this could further decrease the acquisition time, and really start to get low resolution images in under an hour, and complete low resolution tomographic scans (at 10 degree increments, or 36 angles) in under a day. That'd be a substantial improvement over the current system.</p><p><img src="https://cdn.hackaday.io/images/2001871432415780449.jpg"></p><p><b><br></b></p><p><img src="https://cdn.hackaday.io/images/7495661432430734148.jpg"></p><p><b>Mechanical Design</b><br>Given the requirement for long acquisition times (though much shorter than before), I've been sketching up a simplified mechanical design that could be entirely self-contained without any moving parts exposed, and placed on the edge of ones desk to scan away for the duration. I'd also like it to be much more compact than the original design so that it's unobtrusive, while being attractive and interesting enough that it would be a welcome addition to ones desk. The basic design would be a cylinder approximately 6-8 inches in diameter, and 8-12 inches high, with a 2-3 inch diameter aperture in the top to place in a cylindrical acrylic sample container.<br></p><p><img src="https://cdn.hackaday.io/images/7558511432415090872.jpg"></p><p>Moving to a parallel detector removes the need to linearly scan both the source and detector, which removes two of the four axes, greatly simplifying the mechanical design. In this prototype, the idea is that a small sample container slides in through the top, and the sample itself (rather than the source and detectors) will rotate, also greatly simplifying the design.<br></p><p><img src="https://cdn.hackaday.io/images/7264921432415058047.jpg"></p><p>The source and detectors would be mounted on a moving Z-axis (shown above), that translates them up and down to capture different slices of the sample. While here I've included two stepper motors on nylon lead screws for this purpose, in practice this doesn't appear to provide enough support to prevent the Z stage from walking, especially with an unbalanced load — and so this will likely change to three lead screws in the next revision. The drive motors are currently NEMA14 steppers, with a NEMA17 footprint for the sample cylinder support and rotation.<br></p><p><img src="https://cdn.hackaday.io/images/1965691432415072669.jpg"></p><p>So far a great first set of experiments and sketches, and it'll be interesting to better characterize the detector design, make improvements and revisions, and see how it all ultimately affects acquisition time.</p><p>Thanks for reading!</p></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/5946/log/18818-improving-the-parallel-detector-with-photodiode-stacking">Improving the parallel detector with photodiode stacking</a></h2>
                            <small class="authorship">3 months ago  &bull;
                                <a class="gray-link" href="/project/5946/log/18818#discussion-list">
                                    0 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-18818"><p>With the parallel radiation detector design the keystone to the whole project, I've been working to characterize the prototype detector performance, and narrow down a solid design.<br></p><p><img src="https://cdn.hackaday.io/images/3592681433225225003.jpg"></p><p>Taking a step back before jumping into things — in the last post I'd noticed that the detector was reading approximately 20 counts per minute (cpm) from the Barium-133 radioisotope source at a scanning distance of about 6cm. In a way this is fantastic — the detector is working, after all, and with less than a tenth the surface area of the <a href="http://www.radiation-watch.org/p/english.html" target="_blank">Radiation Watch Type 5</a>. But if we (arbitrarily) set a ceiling of 100 counts per pixel as a baseline in order to reconstruct a good image, we would need to integrate for 5 minutes at 20cpm to reach this. Assuming we're scanning an object 6cm in height (or ~20 BPW34 photodiode-sized 3x3mm pixels tall), it would take about 100 minutes to acquire each image. For the computed tomography component, if were we to take images fairly coarsely at 10° intervals, we would end up requiring 360°/10° or 36 images per complete scan. 36 images * 100 minutes per image is 3600 minutes, which is 60 hours, or 2.5 days. That's light years ahead of the current 9 hours per image, but still a little long — ideally we'd get a complete scan to well under a day.</p><p>To help move closer to this, I remembered a trick that my Dad used to use to double the memory in old (sorry, Dad! :) ) computers, where going from 4k to 8k was a huge deal. To do this, he'd order a second set of memory ICs, and physically solder them on top of the existing memory ICs, while lifting one or two pins to hot-wire on a new address line to give access to this larger memory space. I remember this very vividly, not just because we were laughing about it a few weeks ago, but also because when I was at the age where I was taking /everything/ apart that I could get my hands on, he'd given me this sacrificial Tandy Colour Computer that he'd done this to so that I wouldn't accidentally break something more modern, and seeing those stacked chips when I opened up the case was very unusual and memorable.</p><p>In terms of radiation detection, the number of detections depends on the area of the detector, and folks often end up using either one large detector or several smaller detectors to get enough surface area for their application. And while more area means more detections, having a larger detector means that we'd sacrifice spatial resolution. But, unlike the visible radiation the BPW34 photodiode was designed to detect, only about 1% of the x-ray and gamma photons are interacting with the detector, and many of the rest are actually sailing right through the detector. Enter Dad's stacking idea — the BPW34 package just happens to be shaped such that it's amenable to stacking multiple photodiodes one atop another, and if we stack multiple detectors, then we increase our chances of detecting these x-ray photons, and should be able to increase the number of detections without sacrificng spatial solution. Sounds great!</p><p><img src="https://cdn.hackaday.io/images/1568701433225359246.png"></p><p><b>Noise Level</b></p><p>The high-energy particle detector nominally includes three high-level components: A photodiode detector, a very sensitive amplifier, and a microcontroller for counting the detections. The microcontroller appeared to be adding some noise to the process, so I've populated a modified version without the microcontroller, and have been using a scope to characterize the detector.</p><p>The noise level (measured in counts per minute) is pictured above, for three different detection thresholds that appeared to be right around my eyeballed noise threshold of ~50mV. Here we can see empirically that the noise threshold is infact around 50mV, with a near zero number of counts at 52mV, a very small number of counts at 50mV, and many more counts at 48mV.</p><p>Interestingly, the number of photodiodes doesn't appear to affect the noise too much until we reach 4 photodiodes, where the noise level increases quite a bit. Here I've included data from 4 photodiodes at both an 18V bias (ie. two 9V batteries, red), and a 27V bias (purple). So in terms of noise, 3 photodiodes and a ~50mV trigger threshold seems to be a good balance of photodiode surface area vs noise level.</p><p><img src="https://cdn.hackaday.io/images/1005581433225378387.png"></p><p><b>Signal level</b></p><p>The signal story is very similar, though with a bit of a twist. Above we see the signal level (in counts per minute) with the 10uCi Ba133 radioisotope source about 6cm from the detector — enough for the 2 inch sample container with a bit of a mechanical buffer on either side. Here each line represents the difference between the number of detections minus the noise figures from above, so what we're seeing here is just signal level, without the noise.</p><p>Quite wonderfully, we see approximately linear gains when we stack the number of photodiodes, up to 3 photodiodes. Where a single photodiode detects approximately 20cpm (blue), 2 photodiodes detects just under 40cpm (orange), and 3 photodiodes detects about 55cpm (green). The story gets a little more interesting at 4 photodiodes — for 50mV thresholds and higher the detection rate goes up only a small amount to 60cpm, but for a 48mV threshold (well into the noise), the detection rate increases to approximately 80cpm. It's not entirely clear what's happening here, but it looks like 4 photodiodes would be a safe bet — approximately 60cpm at a 50mV threshold, with the possibility for increasing it a good deal lower if we venture into the noise.</p><p>How does this affect the scan time? At 60cpm, we would need only 100 seconds to reach a ceiling of 100 counts, about 30 minutes per image, and 20 hours per 36-angle (10° rotation) scan — much faster than before. In the best case if we assume that we're able to get 80cpm and integrate for only 1 minute per measurement, it would take 20 minutes per image, and 12 hours per scan. This seems to be about the limit (currently) of these radioisotope check source methods: (1) We're using a Ba133 source with emissions that are low enough energy to be most efficiently detected while being just slightly above the noise floor, (2) We're using the maximum amount of this material (10uCi) that can be purchased without a license, (3) The diodes in the detector have been stacked until the edge of diminishing returns, and (4) The scanning volume has been reduced to the minimum usable size. Without significant advances in the way we go about detecting these high-energy particles this is likely pretty close to the best that can be done with such a low intensity source, and raising the intensity of the source (say to an x-ray tube) treads into nuclear safety, regulatory, and legal issues that I'm simply not comfortable with. Given that all the limits have been pushed, 12 hours for a complete scan is much better than the original figure of several weeks, and definitely something I can live with!</p><p><a href="http://www.tricorderproject.org/blog/wp-content/uploads/2015/05/DS1Z_QuickPrint9.png"><img src="http://www.tricorderproject.org/blog/wp-content/uploads/2015/05/DS1Z_QuickPrint9.png" alt="DS1Z_QuickPrint9"></a></p><p><a href="http://www.tricorderproject.org/blog/wp-content/uploads/2015/05/DS1Z_QuickPrint10.png"><img src="http://www.tricorderproject.org/blog/wp-content/uploads/2015/05/DS1Z_QuickPrint10.png" alt="DS1Z_QuickPrint10"></a></p><p><b>Oscilloscope Traces (and measurement noise)</b></p><p>I've captured a few example detections using a Rigol DS1054Z oscilloscope. As near as I can tell this scope isn't capable of counting how many times it has been triggered per unit time, so I connected the trigger output to an Arduino Uno to calculate the number of detections (or counts) per minute (cpm) in the above graphs. Interestingly, I'm not sure whether it was the Arduino Uno or the USB port the Uno was connected to, but this seemed to add bursts of about +/-10mV of noise on the signal every 8 to 12 uSec (this can be seen on the two traces, above). The Arduino Uno clock is 16Mhz which would give a clock period of ~6.25uSec, and USB 2.0 is (I believe) 12Mhz which has a period of 8.3uSec, although I'm not sure why the period of the noise jitters. In either case, the actual noise floor of the system is about 10mV lower, as can be seen on the graphs below, without the Arduino connected.</p><p><a href="http://www.tricorderproject.org/blog/wp-content/uploads/2015/05/DS1Z_QuickPrint14.png"><img src="http://www.tricorderproject.org/blog/wp-content/uploads/2015/05/DS1Z_QuickPrint14.png" alt="DS1Z_QuickPrint14"></a></p><p>This trace (above) looks typical of a high-energy particle detection, likely from one of the higher emissions of Ba133. Because of their energy (and the high magnitude of the detection peak), these are relatively easy to detect.</p><p><a href="http://www.tricorderproject.org/blog/wp-content/uploads/2015/05/DS1Z_QuickPrint21.png"><img src="http://www.tricorderproject.org/blog/wp-content/uploads/2015/05/DS1Z_QuickPrint21.png" alt="DS1Z_QuickPrint21"></a></p><p>The lower emissions (likely around 30-35keV) are much more challenging to detect, and their amplitude is so small that they look very similar to the noise. I believe the trace above represents a noise detection — given the surrounding waveforms one might be tempted to believe that the noise floor is only around +/-20mV, but many of the peaks (on the scale of seconds and minutes) reach to 40mV, making this the effective noise floor.<br></p><p><img src="https://cdn.hackaday.io/images/5639151433225326418.jpg"></p><p>And so, using this preliminary performance characterization, it looks like we're close to nailing down a final design for the detector, and one with much better performance than I was expecting. To accommodate the extra photodiodes I'll have to modify the PCB to extend out another 5mm, and include a slot and pad that the photodiodes can slide into for (ideally) relatively easy surface-mount soldering. In the worst case, if a few of these diodes do have to be hand soldered, a few seconds of soldering is a very small price for 3-4 times the performance. Still, the memory of spending days and days to solder each set of Arducorder boards is fresh in my memory, and I'm endeavoring to design these modular detectors to be as simple and inexpensive to assemble as possible. Removing the microcontroller and adding in the parallel photodiodes, the parts cost in low quantity is about $25 each, about half of which comes from the extremely low noise <a href="http://www.ti.com/lit/ds/symlink/lmp7721.pdf">TI LMP7721</a> precision opamp. Given that the detector is currently operating right at the noise threshold, I'm hesitant to substitute this part for a less expensive opamp, but with TI as an official sponsor of the Hackaday Prize and an array of detectors to build, perhaps they'll be able to donate a tube of these parts to the cause of open source science.</p><p><img src="https://cdn.hackaday.io/images/5958231433225474734.jpg"></p><p><b>Mechanical Design</b></p><p>With 4 photodiodes, the current detector design extends to about 40mm in length, and (after wrapping with aluminum shielding) about 4.5mm to 5mm in thickness. With a 2 inch acrylic sample container, and a ~3mm buffer on either side of the container, this allows a packing density of exactly 16 detectors over a 75° fan angle from the source.</p><p>For compactness and supply, I'd like to keep the design to within 6 inches in diameter — and 6 inch cylinders of various sizes are much more easily found (and much less expensive) than moving up to 8 inches. Home Depot even carries a fairly hefty 6 inch (~5.7 inch ID) drain pipe that's inexpensive, extremely sturdy, and would be perfect for prototyping case designs with. Unfortunately 40mm detectors are a bit too large to fit within this size — it looks like the detector would have to decrease to 30mm or less to squeeze into a 6 inch cylinder.<br></p><p><img src="https://cdn.hackaday.io/images/3645511433225492785.jpg"></p><p>Another option, shown here, is to throw symmetry to the wind and slightly offset the sample container, giving the whole unit a clear "front" and "back". This is a fairly simple solution, and I'd like to include a front display panel for the device as well — so if several stepper motors and lead screws can effectively fit into this footprint, it might be a very good solution.</p><p>Thanks for reading!</p></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/5946/log/19674-board-design-and-tomography-platform-mega-update">Board Design and Tomography Platform Mega-Update</a></h2>
                            <small class="authorship">2 months ago  &bull;
                                <a class="gray-link" href="/project/5946/log/19674#discussion-list">
                                    0 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-19674"><p>An update with a great deal of progress, including the design for the first revision of the imaging array, and a second iteration of the mechanical tomographic scanning framework. </p><p><img src="https://cdn.hackaday.io/images/8187731434598065329.jpg"></p><p>From the last update, the initial characterization of the prototype modular radiation sensor looked very promising -- it's able to detect about 60-80 x-ray photons per minute at a distance of 6cm from the radioisotope source, which should be more than enough to generate an image.   While characterizing the prototype detector I identified a number of revisions, and so my recent focus has been on working through everything required to build the complete imaging array.</p><p><img src="https://cdn.hackaday.io/images/8586971434598093791.jpg"></p><p><strong>Radiation Detector Revision 1</strong></p><p>The prototype detector generally worked out rather well, and was designed to be amenable to a bit of wire wrap when issues came up (as an aside, I tend to use vias to attach probes and wire wraps, so my vias are often left untented for this purpose).  I found a few issues that required a significant revision:</p><p><em>Things that worked well: </em></p><ul><li><strong>Relatively low-noise:</strong> The detector has a very similar noise level (~+/-40mV) to what I've measured with the great <a href="http://www.radiation-watch.org/p/english.html">Radiation Watch</a> Type 5 (~+/-50-60mV).  This is really an accomplishment for me given that I haven't designed many challenging analog systems, and low noise really enables this design. </li><li><strong>Detection level: </strong><span class="redactor-invisible-space">The detection level was originally about 20 x-ray photons per BPW34S photodiode (@6cm) per minute, which is really very reasonable for a first pass.  The Type 5 in the <a href="https://hackaday.io/project/1395" target="_blank">Arducorder Mini</a> detects about 500 photons at this same distance, but it has a factor of 13.3x more detection area (so we'd expect the BPW34S to detect around 38 photons per minute, normalizing for detection area).  Given that the beautiful <a href="http://www.first-sensor.com/cms/upload/datasheets/X100-7_SMD_501401.pdf">First Sensor X100-7</a><span class="redactor-invisible-space"> photodiode used by the Type 5 is specifically designed for radiation detection and has a cost of about $100, while the BPW34S photodiode is a ~$1 part, we're really doing very well.</span><br></span></li><li><span class="redactor-invisible-space"><strong>Increasing Detection Level:</strong> The last post showed that the BPW34S photodiodes can be stacked in parallel, increasing the detection rate to ~60-80cpm, while not decreasing spatial resolution -- so we're doing very well here.  A few dollars in inexpensive photodiodes is functionally getting us very similar performance to the fantastic X100-7 photodiode (for this task), and we're (again) really doing very well. </span></li><li><span class="redactor-invisible-space"><strong>Digitally adjustable:</strong><span class="redactor-invisible-space"> The comparator threshold can be digitally adjusted using an AD5160 digital potentiometer, and this is really handy to be able to adjust the detector's output to a desired noise level. </span></span></li><li><span class="redactor-invisible-space"><span class="redactor-invisible-space"><strong>Modest Soldering Skills:</strong>  The board was designed to require only modest surface mount soldering skills (0603 passives, and SOIC ICs with the exception of the digipot), so they can be hand assembled relatively quickly.</span></span></li></ul><p><em>Things that needed work:</em></p><ul><li><strong>Microcontroller:</strong> I'd initially hoped that each modular radiation sensor would a be a "smart" detector, having it's own digital interface to ease data collection. Unfortunately even with my first pass at isolating things the microcontroller introduced too much noise into the analog portions of the system, and had to be removed. <a href="http://www.microchip.com/wwwproducts/Devices.aspx?product=PIC24F32KA301"></a></li><li><strong>Analog to Digital Conversion:</strong> I've been very interested in developing a detector that can do very crude spectroscopy / energy level differentiation, to help render more informative scans. I've been crudely doing something similar to this with the Arducorder Mini, measuring the pulse widths from the Type 5, which tend to <em>correlate</em> with pulse height -- but of course actually measuring the pulse height should be much more accurate.  To do this I'd piped the amplified analog voltage (before the comparator) to one of the ADC channels of the <a href="http://www.microchip.com/wwwproducts/Devices.aspx?product=PIC24F32KA301">PIC24FV32KA301</a>, which has a 12-bit ADC, at a 100Ksps sample speed.  Unfortunately while some of the very largest peaks could reach ~10uSec (100Ksps) in duration, most of them are much shorter -- on the order of ~1uSec (1Msps).  I don't have a lot of experience with fast analog signal peak detection, but I suspect one would require a significantly more complicated (and expensive) circuit to do this well.  I'm very interested in this, but it will likely require more thought, and (unfortunately) likely won't make it into this iteration.  </li><li><strong>Gain:</strong> I increased the gain on both the preamplifier and dual amplifier stages. </li><li><strong>Shield:</strong><span class="redactor-invisible-space"> A grounded foil shield surrounding the sensor is absolutely critical, but I had neglected to put a solder point on for the shield in the previous iteration -- so this was added in.</span></li><li><span class="redactor-invisible-space"><strong>Size:</strong><span class="redactor-invisible-space"> In order to fit into the 6" diameter enclosure symmetrically, the modular detectors needed to be reduced to a length of no more than 30mm, which required a bit of work (see figure below). </span></span></li><li><span class="redactor-invisible-space"><span class="redactor-invisible-space"><strong>Easy stacking: </strong>The photodiode stacking is giving near-linear increases in detection efficiency for low numbers of photodiodes, which is incredible, but I needed a simple way to make this compatible with surface mount soldering.  I redesigned the footprint for the BPW34S to allow a stack of up to 4 photodiodes to snugly fit in a special slot, and be surface mount soldered in a normal reflow process.  They'll still have to be hand placed, but a few seconds of work is easily work it for increasing the detector's performance by a factor of 3 (!). <br><br></span></span></li></ul><p><img src="https://cdn.hackaday.io/images/8461501434598132412.jpg"></p><p>The schematic for the modular radiation detector (revision 1) is pictured above.  Most of the revisions affected component values and mechanical layout, with the exception of moving the microcontroller offboard.  PDFs of the schematics (as well as the Eagle files) are available in the <a href="https://github.com/tricorderproject/openct2/tree/master/hardware/radiationsensor_r1" target="_blank">OpenCT2 Github repository</a>. </p><p><img src="https://cdn.hackaday.io/images/6094901434598171825.jpg">With stacking the BPW34S photodiodes, the total length of the prototype detector had increased to about 40mm.  With my completely arbitrary and aesthetic desire to fit the entire device into inexpensive 6 inch PVC tubes (with a 5.7" inner diameter), the detector board had to be reduced to a maximum of 30mm in length to fit symmetrically.  Sacrificing a bit of height for the sake of symmetry, this first revision of the detector comes in at ~30mm x 48mm, allowing for the symmetrical design above. </p><p><img src="https://cdn.hackaday.io/images/3673531434598192075.jpg"></p><p><strong>Imaging Array Board</strong><br></p><p>The imaging array board (above) functions to hold in place 16 of the detectors that together make up the imaging array.  Here, each detector is equidistant from the source (at 2.25 inches or ~6cm), and rotated about 5 degrees with respect to the neighbouring detectors such that their photodiodes are facing straight towards the source -- the orientation where they're most efficient. </p><p>I really enjoy the shape of this board, and it's certainly one of the more unusual designs that I've had the opportunity to put together.  It's functions are largely mechanical, but it also includes a header to connect a separate Microcontroller Board (below) that interfaces to each of the 16 detector modules, and performs the actual counting.  While the comparator output pins of the detector modules are all brought out to the microcontroller connector, the SPI pins for the digital potentiometers are brought out to an I/O expander (a <a href="http://www.microchip.com/wwwproducts/Devices.aspx?product=MCP23017" target="_blank">Microchip MCP23017</a>) to handle toggling the 16 independent chip select (CS) lines.  It's not entirely clear whether the digipots on each detector will all have the same calibration setting, or whether they'll each require slightly different settings, so here on this prototype the I/O expander is included to allow for the possibility of setting each one individually.  It's important to make our mistakes cheaply, after all.</p><p><img src="https://cdn.hackaday.io/images/9087281434598203885.jpg"></p><p>The Microcontroller board (above), from a functional perspective, needs to wait for detection pulses from each of the 16 detectors, count them over a period of time, and then communicate the total number of counts from each detector (after about a minute of collecting data) to another board, say a Raspberry Pi, that's controlling the whole show, and generating the images.  </p><p>Nominally this is a perfect job for an FPGA, but they're a little challenging to program, and it's been a few years since I've tinkered with one.  Many of the larger Microchip microcontrollers have 16 or more Change Notification (CN) I/O pins, which can trigger interrupts, and would also be very suitable for this task -- though that would require soldering a TQFP.  While I would normally make this decision, I'm continually trying to be attentive to making open source projects accessible whenever possible -- I tend to design projects that are extremely challenging to assemble for the average maker. For example, the <a href="https://hackaday.io/project/1395" target="_blank">Arducorder Mini</a> includes a fine-pitched 100-pin TQFP for the microcontroller and many other leadless fine pitched parts, and other than the handful that I've made and sent out, I've not yet heard of an Arducorder made in the wild -- although I'm very happy that parts of the design, like drivers and reference schematics for the Hamamatsu Microspectrometer, are being used.  One of the best feelings that you get as an open content author is when people make, use, and modify your designs, and I'm making an effort to design the OpenCT2 such that the most complex bits could be assembled by a capable undergraduate student with very modest surface mount soldering exposure. </p><p>In light of this, I've opted to include Sparkfun's great <a href="https://www.sparkfun.com/products/11113" target="_blank">Arduino Pro Mini</a>, which is extremely easy to solder, inexpensive, and has *just* enough pins to cover the task.  It can also very easily communicate to a Raspberry Pi (or other host computer) with an FTDI USB-&gt;Serial cable, and can be reprogrammed with the popular Arduino IDE, which should encourage tinkering, learning, and experimenting from the community and budding computed tomography students/enthusiasts. </p><p><img src="https://cdn.hackaday.io/images/4405541434598254923.jpg"></p><p><strong>Physical Tomographic Framework</strong><br></p><p>While I've been waiting for the boards to be fabricated, I've had a bit of time to tinker with the mechanical bits of the project.  Both the imaging array and the mechanical tomography machinery have physical constraints (for example, a lead screw can't go through a detector), and so the design of both the imaging boards and the linear stages had a lot of back-and-forth. </p><p><img src="https://cdn.hackaday.io/images/1671551434598265068.jpg"></p><p>Lately I've been really interested in round/organic designs, and also in arrays of things -- and so I've tried to include these themes into this project, both with the array of detectors, and the interesting design challenges that come with making something that's round and has a lot of moving parts. </p><p>The current design is about 11 inches high and just under 5.7 inches in diameter, which allows it to easily housed in a standard 6 inch PVC plumbing pipe from a local hardware store (like Home Depot).  </p><p><img src="https://cdn.hackaday.io/images/5858231434598277343.jpg"></p><p>The design has two main axes of motion, which is greatly simplified over the original OpenCT -- a linear stage, that moves the entire imaging array up and down, as well as a rotary stage, that rotates the sample 360 degrees (here represented with the clear acrylic sample container).  Previously I'd used only two lead screws to index the linear stage, but this was really wishful thinking, and the staged walked from side to side quite a bit instead of moving smoothly. </p><p>Here, I've added an extra motor to the linear stage (bringing the total up to 3), which should make the motion much smoother, and add a bit more support for the imaging array, the Barium 133 radioisotope source, as well as a generous amount of lead shielding.  Not having a lot of experience with things made out of solid lead, you /know/ it's going to be heavy before you pick it up, but it's still way heavier than you expect.</p><p><img src="https://cdn.hackaday.io/images/7277191434598286643.jpg"></p><p>The motor for the rotational stage was originally a NEMA17, but I've sized this down to a NEMA14 to match the other motors, given that it shouldn't require very much torque to get the sample moving.  This also keeps the design (and the BOM) a bit simpler. </p><p><img src="https://cdn.hackaday.io/images/5589401434598295572.jpg"></p><p>The couplers are the inexpensive aluminum flex couplers that go from the M5 stepper motor shafts to the M8 nylon lead screw.  These </p><p><img src="https://cdn.hackaday.io/images/5856381434598307947.jpg"></p><p>From the top down, here we can see the top supports for the nylon lead screws, as well as the tops of the three steel threaded rods that extend from top to bottom, and are used as a structural supports for the entire mechanism. </p><p><img src="https://cdn.hackaday.io/images/7719381434598318207.jpg"></p><p><strong>Imaging Array Carriage</strong><br></p><p>The Imaging Array Carriage (above) houses the imaging detector array and source, and indexes up and down around the 2-inch diameter acrylic sample container.  Here a mock-up of the imaging array board can be seen, to give a rough idea of fit while the boards are being manufactured. </p><p><img src="https://cdn.hackaday.io/images/2356231434598331803.jpg"></p><p>At about 70mm in height, the imaging array carriage is a little higher than I was expecting, but it's very workable for a first pass.  The height largely comes from the 48mm required for each detector, not including the connector and the Imaging Array Board itself.</p><p><img src="https://cdn.hackaday.io/images/1581051434598341219.jpg"></p><p>Like the two linear axes inside of the original OpenCT bore, I've found that inexpensive aluminum rod (here 0.25 inch) and nylon bushings available anywhere from McMaster-Carr to a local hardware store work very well as linear slides. </p><p><img src="https://cdn.hackaday.io/images/9683311434598350406.jpg"></p><p>I've also been using nylon lead screws lately for projects where keeping things light is an asset, and absolute precision isn't required.  With traditional stages assembled using steel threaded rod, I've found that unless you're willing to use rod designed for linear motion, it often has very slight bends or otherwise generates alignment problems that can be frustrating to deal with.  Here, the nylon lead screw (and nylon nut) are extremely inexpensive, light, and have a bit of give to help adjust to any alignment issues.  Note that the nuts are normally sandwiched in between two pieces of MDF, but they haven't yet been installed in this picture. </p><p><img src="https://cdn.hackaday.io/images/9448021434598363931.jpg"></p><p><strong>Mechanical Controller</strong><br></p><p>It's my hope that the project will have three main contributions, each dependent upon the last:</p><ol><li>An inexpensive high-energy particle detector</li><li>An imaging array and supporting hardware, composed of many detectors</li><li>A physical mechanical platform for desktop computed tomography or scanning, whether coupled with the above imaging array, or any other sensor or imaging array a student, researcher, or enthusiast might use.</li></ol><p>To make things accessible, I'm trying to keep each component as easy as possible for folks to assemble.  While each detector (1) does require modest surface mount soldering exposure, I'm trying to design the imaging array (2) to largely require only through-hole soldering, and the mechanical CT platform and control electronics (3) to require minimal soldering and use as many off-the-shelf components as possible -- something that you might see as a set of instructions in <em>Make Magazine</em> rather than a laborious set of assembly instructions sent to a contract manufacturer. </p><p>With this goal in mind, I'm trying to see if a regular Arduino Uno and Motor Shield (to control the motion) coupled with a Raspberry Pi (for a Wifi-enabled user interface) will be sufficiently powerful to do everything that needs to be done, while keeping everything very off-the-shelf and accessible. </p><p><img src="https://cdn.hackaday.io/images/1430591434598372804.jpg"></p><p>Both the Arduino Uno and Raspberry Pi currently have mount points at the bottom of the tomography platform, just under the motors.  They're mounted outward to allow easy access to the various connectors, and make assembly and maintenance as easy as possible. </p><p><img src="https://cdn.hackaday.io/images/3567191434598383236.jpg"></p><p>Thanks for reading!</p></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/5946/log/20074-assembling-and-characterizing-the-modular-detector-rev1">Assembling and characterizing the modular detector (rev1)</a></h2>
                            <small class="authorship">2 months ago  &bull;
                                <a class="gray-link" href="/project/5946/log/20074#discussion-list">
                                    2 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-20074"><p>The revised high energy particle detector boards arrived, and I've had the chance to put one together and verify it working over the weekend — and snapped some pictures of the assembly process along the way. This (long!) post details the assembly process, and (towards the bottom) describes some initial characterization of the detector, including a histogram of detector variability.</p><p><img src="https://cdn.hackaday.io/images/913921435429804592.jpg"></p><p>Pictured above is one of the Radiation Sensor Revision 1 boards, coupled with the very curiously-shaped Imaging Array board. It’s not often that I find myself having to design boards in interesting shapes, and while the first goal is of course to design something that works, it’s always wonderful when you have the opportunity to make it look aesthetically pleasing, too.</p><p><img src="https://cdn.hackaday.io/images/4824611435429831999.jpg"></p><p><strong>Assembly</strong><br>The Radiation Sensor Revision 1 designs are available <a href="https://github.com/tricorderproject/openct2/tree/master/hardware/radiationsensor_r1">on Github</a>, including the schematics, gerbers, and parts list. The boards I’ve shown have been ordered from <a href="http://www.oshpark.com/">OSH Park</a>, and the stencil from <a href="http://www.oshstencils.com/">OSH Stencils</a>. Most of the component values are included on the board silkscreen, so it’s generally a comfortable assembly process if you have experience assembling a few surface mount boards.  (Note that the detector I've assembled here has had C2 changed from a 4.7pF to 2.2pF to examine if a higher gain on the first stage significantly improves signal to noise, but so far it looks like either value should work just fine). </p><p>In addition to the normal surface mount soldering process, there are a few additional steps in the assembly process to accommodate bending the photodiode leads, creating a light-tight wrap, and applying the grounded shield. These are a bit atypical, so I’ve documented them here.</p><p><img src="https://cdn.hackaday.io/images/2003631435429852495.jpg"></p><p><strong>Photodiode Angling/Stacking Jig</strong><br>The detector uses an array of four BPW34S photodiodes stacked one atop each other (and, laying on their side) to dramatically increase detection efficiency. Straight out of the tube these photodiodes generally come with leads that are 90 degrees from the main body, and need to be slightly angled so that they easily sit atop one another (and make contact with the surface mount pads on the board).<br></p><p><img src="https://cdn.hackaday.io/images/6639531435429867638.jpg"></p><p>A small laser-cuttable jig to perform this bending is available <a href="https://github.com/tricorderproject/openct2/tree/master/mechanical/jigs">here</a>, and pictured above. The jig contains 10, 20, and 30 degree pin angles — I find that the 20 degree works optimally. To bend the photodiode, lightly squish it onto the jig, and the pins will spread to the appropriate angle. I have found that 3/16″ acrylic worked well for this jig, being about the same width as the photodiode.</p><p><img src="https://cdn.hackaday.io/images/8061401435429880823.jpg"></p><p>Above we can see the difference in between the original pin angle (left) and pins angled slightly at 20 degrees (right) to enable stacking. I recommend that the photodiodes be the last components placed on the board, using tweezers, and sitting (laying?) flush one atop another.</p><p><img src="https://cdn.hackaday.io/images/4425841435429897318.jpg"></p><p><strong>Connector Lead Trimming</strong><br>To get as high an imaging resolution as possible and increase the packing efficiency, the detectors have been designed to be as thin as possible — only 4mm (!) on the imaging dimension. To ensure that they’re as thin as possible, the main 9-pin male connector (bottom) may need to be slightly trimmed, depending on the part you use.</p><p><img src="https://cdn.hackaday.io/images/8113761435429916926.jpg"></p><p>(The imaging array board for the “cat” scanner, with an actual cat, for size).<br></p><p><img src="https://cdn.hackaday.io/images/4838171435429948589.jpg"></p><p>The connector that I’ve spec’d for the radiation sensor boards is Digikey #<a href="http://www.digikey.com/product-search/en?x=0&amp;y=0&amp;keywords=S1111EC-09-ND">S1111EC-09-ND</a>. I looked for a connector with the shortest leads that I could find, and confess that from the datasheet I had expected the pins to be a little shorter. Normally you could use a surface mount connector for this and not have to deal with through-hole leads poking out of the back of the board, but the alignment of our imaging array is important, so I’ve included the through-hole connector with slightly offset pins to encourage the connector to align properly. I’m also convinced that the through-hole connector is likely more mechanically stable than a surface-mount version.<br></p><p><img src="https://cdn.hackaday.io/images/8247241435429973896.jpg"></p><p>Here (above) we can see the start of the pins being trimmed — either a standard pair of wire trimmers or right-angle trimmers should work well for this.</p><p><img src="https://cdn.hackaday.io/images/6572071435429989200.jpg"></p><p>And here each of the pins has been trimmed. When soldering, don’t forget to warm up the pin before applying the solder — it’s important to encourage the solder to fill the hole from top to bottom, and be both mechanically rigid and a solid conductor.</p><p><img src="https://cdn.hackaday.io/images/4134831435430001006.jpg"></p><p>The board, after soldering on the connector. Ready for wrapping!</p><p><img src="https://cdn.hackaday.io/images/2563441435430026663.jpg"></p><p><strong>Wrapping Part 1: Insulating light-tight layer</strong></p><p>The detector has to be wrapped in several layers — both to shield the photodiode from any external light, and provide a grounded conductive shield to reduce the electrical noise. I do the wrap in two layers — a layer of black electrical tape (to shield from light, and insulate the board from the conductive tape), then a layer of aluminum tape for the grounded shield.</p><p>Here, I prefer to start at the the top of the back of the board…<br></p><p><img src="https://cdn.hackaday.io/images/8291761435430039754.jpg"></p><p>Then wrap around the front, completely covering the photodiode stack with a single layer of electrical tape. From here, I wrap around the back again…<br></p><p><img src="https://cdn.hackaday.io/images/9734621435430053350.jpg"></p><p>… and several more times, until the entire board (including all parts and vias) are covered, save the connector at the bottom, and the “shield” pad on the back of the board at the bottom (below). I try not to cover the bulk of the photodiodes in more than one layer of electrical tape, so that the photons don’t have more bulk material to go through before hitting the photodiodes (not that the electrical tape is likely to be terribly absorptive).</p><p>While the top (component side) of the board will be a little bumpy from all the components, try to wrap the back side of the board as smoothly as possible, as we’ll have a mechanical ground wire connection to place here in a moment.<br></p><p><img src="https://cdn.hackaday.io/images/5866101435430070113.jpg"></p><p><img src="https://cdn.hackaday.io/images/7673711435430081485.jpg"></p><p><strong>Wrapping Part 2: Grounded Aluminum Shield</strong><br>The second layer is a wrap of Aluminum tape that surrounds the detector and provides a grounded electrical shield that reduces electrical noise. This is a critical part of the circuit, so take your time to ensure that the shield is well crafted.</p><p>The first component of the shield is the ground wire (above). Cut a piece of stranded wire about 1.5 inches in length, with a small section stripped at the bottom, and a much larger section stripped near the top. Pre-tin the bottom section, but do not apply any solder or twist the large stripped section at the top (this will make sense in a moment).<br></p><p><img src="https://cdn.hackaday.io/images/8343641435430096454.jpg"></p><p>Solder the ground wire to the ground pad on the back side of the board. I recommend holding the wire down with another piece of electrical tape (while soldering) to ensure that it’s as flat to the circuit board as possible. We’re about to cover the back of the board in aluminum tape, so try to ensure that the back is as flat as possible.</p><p><img src="https://cdn.hackaday.io/images/3976311435430111722.jpg"></p><p>We can’t solder the ground wire to the aluminum tape, so we have to make a solid mechanical connection. The method that I’m showing here is what I’ve inferred is likely used with the <a href="http://www.radiation-watch.org/">Radiation Watch Type 5</a>, after carefully examining it.</p><p>Cut a piece of aluminum tape that’s about three times as long as the detector is wide (~10cm). The aluminum tape I use is standard off-the-shelf tape from Home Depot intended for sealing ventilation conduits.</p><p>Make the first layer on the back of the board (as shown above), aligned with the edge of the board on one side, and just above the shield pad/electrical tape on the other. Remember, ensure that the electrical tape covers /all/ components and vias with a margin of a few millimeters, and ensure that the aluminum tape is seated completely on the electrical tape (with a bit of a margin) and not touching the board — otherwise it may bridge and cause a short circuit!</p><p>It’s okay (and preferred) for the tape to extend over the top of the board a little — just cut a seam along one edge,…<br></p><p><img src="https://cdn.hackaday.io/images/6031851435430125008.jpg"></p><p>… and bend it over the top of the board, as above.<br></p><p><img src="https://cdn.hackaday.io/images/3810181435430144026.jpg"></p><p>Place the board in a board vice, and carefully fan out the stranded wires over the back of the board, as above. The idea here is that they will be sandwiched between the conductive layer of aluminum tape below them, and the adhesive layer of aluminum tape we’re about to put overtop of them.</p><p>Note that the more stands we have in the stranded wire, the better the connection is likely to be. The wire that I’ve spec’d for this (Digikey <a href="http://www.digikey.com/product-search/en?vendor=0&amp;keywords=CN100B-25-ND">#CN100B-25-ND</a>) is 22awg 17 conductor strand wire, which has many more strands than the cheap 7 strand wires, and should perform much better for this task.<br></p><p><img src="https://cdn.hackaday.io/images/3807451435430157600.jpg"></p><p>Wrap the aluminum tape over the front of the board. For the excess tape over the top, again cut a small slit along the seam, and fold the excess down onto the top of the board.<br></p><p><img src="https://cdn.hackaday.io/images/9690411435430172334.jpg"></p><p>Now the critical fold — slowly fold the tape over the back (and the bare stranded wire), ensuring that it’s reasonably tight, and squished down such that the stranded wire is very firmly pressed into place against the underlying layer of aluminum tape. Use a meter to verify that the aluminum tape shield is effectively grounded.</p><p><img src="https://cdn.hackaday.io/images/6673091435430232319.jpg"></p><p>And, lastly, fold any excess over the top of the board. Congratulations, the board should be light-tight, and electrically shielded! Don’t forget to use a meter to verify that the shield is grounded, and that there aren’t any electrical bridges between the shield and any of the pins on the connector.<br></p><p><img src="https://cdn.hackaday.io/images/6458601435430259152.jpg"></p><p><strong>Performance and Measurement Variability</strong><br>In terms of general performance, with the 10uCi Barium-133 radioisotope source ~6cm away from the detector, the detector measures an average of 70 counts per minute (cpm). </p><p>Absorbance imaging from a weak radioisotope source is an interesting problem — if you think of another (simpler) example of absorbance imaging, holding up a film negative or slide to a lamp, assuming the lamp you’re using to backlight the slide is fairly uniform, it’s easy to make out the picture on the slide. With weak radioisotope imaging, the source is fantastically more dim, and so instead of having an enormous stream of photons backlighting the sample, we’re essentially counting single photons as they interact with the detector, about one per second. On timescales of minutes to hours the average rate that the Ba133 source emits these photons is about constant, but on the shorter timescales that we’re using for imaging, there’s much more variability (a phenomenon known as <a href="https://en.wikipedia.org/wiki/Shot_noise">shot noise</a>). For imaging, this is further complicated in that x-ray photons are being emitted from the source in all directions, but each pixel is very small — at a 6cm radius around the source, a sphere has a surface area of 45,238mm^2, but each detector is sensing photons from only 7.5mm^2 of that sphere (a difference of a factor of over 6,000), so there will be quite a bit more variability in our measurements. But how much?</p><p>Above I’ve plotted a histogram that helps illustrate the measurement variability using a technique called <a href="https://en.wikipedia.org/wiki/Bootstrapping_(statistics)">Bootstrap Resampling</a>. Here, I’ve connected up an Arduino Uno to the detector, and set it to listen for detections for 10 seconds, and report the detection rate (in cpm). I then do this many times over the course of about 2 hours, until there are nearly 1000 of these 10 second measurements, and plot them as the blue line in the histogram. Here we can see that there’s quite a bit of variability in these short measurements — they span from about 20cpm, when few photons happened to be emitted in the direction of the detector over a given 10 second interval, to 140cpm, where there was a photon party in detector town, and everyone was invited. The bulk of the measurements show rates of between 40-100cpm, with a roughly Gaussian distribution. (For those interested, the raw data is available <a href="http://www.tricorderproject.org/blog/wp-content/uploads/2015/06/bootstrap_170_10sec.csv">here</a>, and the <a href="https://plot.ly/~upontheturtlesback/72">histogram is available</a> on Plotly).</p><p>To simulate the variability at integration times longer than 10 seconds, I use bootstrap resampling to randomly draw a number of 10 second samples, and average them. For example, to simulate a 20 second integration time, one would randomly draw two 10 second samples, and average them. To simulate a minute long integration time, one would randomly draw six 10 second samples, and average them. If you do this random resampling many times — here about 10,000 times per integration time, then you can simulate a smooth distribution.</p><table><tbody><tr><td>Integration Time</td><td>10s</td><td>30s</td><td>1m</td><td>2m</td><td>5m</td><td>10m</td></tr><tr><td>Standard Deviation</td><td>20.3</td><td>11.7</td><td>8.4</td><td>5.8</td><td>3.7</td><td>2.6</td></tr></tbody></table><p>Here we can see both on the histogram and in the table (above) that on timescales of tens of seconds, the variability is quite large compared to the average rate (over long timescales) of 70cpm. For those not familiar with statistics, the <a href="https://en.wikipedia.org/wiki/Standard_deviation">Standard Deviation</a> is a measure of variability in a Guassian-shaped distribution. The measured value will be between +/- one standard deviation from the mean value of 70cpm about 68% of the time, and within +/- two standard deviations of the mean value 95% of the time.</p><p>Here we can see that on timescales of tens of seconds, the variability is quite large — at a sample time of only 10 seconds, we’ll measure a rate of 70 ±20cpm (or 50-90cpm) 68% of the time, and a rate of 70 ±(20*2=40)cpm (or 30-110cpm) 95% of the time. That’s very large, and so such short integration times won’t be very useful for imaging — with such a high variability, the image would <a href="https://en.wikipedia.org/wiki/Shot_noise#/media/File:Photon-noise.jpg">look very noisy</a>.</p><p>The integration time follows the Poisson relationship, such that measuring for <i>N</i> times longer decreases the variability in the measurement by sqrt(N) — so measuring for twice as long decreases the variability by a factor of about 1.4, and measuring for 4 times as long decreases the variability by a factor of 2. We can see this in the table above, where the standard deviation at a 2 min/120 sec integration time (5.8) is twice as stable as the variability at only a 30 second integration time (11.7). The target (“within the limit of patience”) integration time of 120 seconds means the signal intensity will vary from 70 ±5.8cpm (64-76cpm) most of the time, to 70 ±12cpm (58-82cpm) 95% of the time. This should be more than enough to generate a low-resolution image, and with some filtering we may be able to clean up a bit of the noise in the images as well.</p><p><strong>Next Steps</strong></p><p>The next step is to put together a partial array of detectors (about 4) to verify their performance and repeatability.  If everything looks good, the imaging array can be mounted onto the tomography platform, and we can move towards collecting the first imaging data.</p><p><strong>Acknowledgements</strong><br></p><p>I'd like to thank the generous folks at <a href="http://www.ti.com/" target="_blank">Texas Instruments</a> for sending along enough of their exceptionally low-noise <a href="http://www.ti.com/product/lmp7721" target="_blank">LMP7721</a> Precision Amplifiers to complete the array.  </p><p><img src="https://cdn.hackaday.io/images/1061971435433353116.png"></p><p>Thanks for reading!</p></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/5946/log/20562-partial-imaging-array-and-better-mechanical-platform">Partial Imaging Array, and Better Mechanical Platform</a></h2>
                            <small class="authorship">a month ago  &bull;
                                <a class="gray-link" href="/project/5946/log/20562#discussion-list">
                                    5 comments
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-20562"><p>A few years ago, while sitting in on a grad class in computational sensing, I (a Canadian) had my first real experience with the American healthcare system, and proclaimed whilst in (billing-related) shock that one day I would create a CT scanner for less than the billed cost of one scan.  While I've had to scale back a bit over my original ambitions -- it's much smaller, and much slower, given my aversion to radioactive things -- in the past week I've felt as though it's really starting to take shape, and that a few months of planning and design revision are starting to come together.</p><p><img src="https://cdn.hackaday.io/images/9645461436244498691.jpg"></p><p>I had the chance to put together four of the modular radiation sensors, place them on the array board, populate the tiny Arduino control board -- and it all came together great.   I wrote some very basic firmware that listens for pin-change interrupts, checks which pins have changed, and adds counts for the respective detector.  It seems to be working wonderfully. </p><p>Like the Radiation Watch Type 5 detector in the <a href="https://hackaday.io/project/1395-open-source-science-tricorder" target="_blank">Arducorder Mini</a>, I added in a pulse width histogram into the driver for this imaging array, to see if it's capable of doing very crude spectroscopy.  Unfortunately while pulse height is correlated with energy, pulse width with this detector is nearly always 10-20uSec, and not terribly useful for energy level discrimination.  That being said, the digipot on the comparator allows one to dynamically set the detection threshold, so it's likely still possible to do energy level discrimination, but at the expense of multiple exposures.  I'm looking forward to experimenting with this.</p><p>There is a bit of variance in the noise level of the detectors, and the digipots do clearly have to be set to slightly different values (a few millivolts apart) to see the same signal-to-noise characteristics on each detector.  This is good to know, and really justifies having added the ability to individually set the comparator thresholds on each detector using the <a href="http://www.microchip.com/wwwproducts/Devices.aspx?product=MCP23017" target="_blank">MCP23017</a> I/O expander. </p><p><img src="https://cdn.hackaday.io/images/8809481436244513761.jpg"></p><p>I decided to make a major mechanical change, and increase the sample container size from 2 inches in diameter to 3 inches.  I had originally planned to use a 3 inch container with a scan volume the size of a pop can, but lowered it both to (1) increase the signal-to-noise ratio, and (2) keep the total build size of the machine to within 6 inches in diameter.  </p><p>While I had convinced myself that there'd be plenty of interesting things to scan that were less than 2 inches in diameter (like the bags of tiny peppers in the grocery store), after building the tiny 4-detector array, I simply couldn't find many things that would fit for a quick test -- everything was just slightly too big.  Science is about trying not to fool yourself, when you're the easiest one to fool.  I had fooled myself into thinking that the smaller diameter would work for the benefits in SNR, but when confronted with real test cases, it just isn't practical.  This is a big of an expensive mistake given that it means I have to redesign the imaging array for a larger sample container size, but it's much better to make the change now and have a much more useful instrument. </p><p><img src="https://cdn.hackaday.io/images/994371436244537822.jpg"></p><p>Limiting the machine size to 6 inches in diameter also isn't practical for a 3 inch sample container, though I have had trouble sourcing larger 8 inch PVC tubes to use as an easy enclosure.  David Forbes of <a href="http://www.cathodecorner.com/nixiewatch/index.html" target="_blank">Nixie Watch</a> fame happened to know an <a href="http://flexpvc.com/indexPVCPipe.shtml" target="_blank">online store</a> that stocks a variety of PVC pipe sizes with very reasonable shipping for enormous heavy tubes, with an 8-inch diameter by 14-inch height thin-walled tube costing only about $20, shipped -- so this solved a major issue, and the size of the machine can now easily increase. </p><p><img src="https://cdn.hackaday.io/images/5148811436244752527.jpg"></p><p>With an increase in size from 6 inches to 8 inches, this allows just enough room for more conventional linear motion systems, like the <a href="https://www.inventables.com/technologies/makerslide" target="_blank">Makerslide</a> v-wheel based aluminum extrusion. This is very easy to get ahold of through Inventables, and much more rigid than my laser cut system.   Here I've cut down a large piece into two 24cm sections, and milled the faces to be completely flat after the cut. </p><p><img src="https://cdn.hackaday.io/images/6415711436244769245.jpg"></p><p>The Makerslide attaches to the frame on edge through two M5-tapped holes at either end of the extrusion.  This <a href="http://www.thingiverse.com/thing:24911" target="_blank">3D-printable tapping jig</a> on Thingiverse is absolutely essential for this -- a few years ago I tried tapping Makerslide without a jig, and the result was horrible.  "Cut a full turn, then back off half a turn to let the material work it's way out.  Keep repeating this until your tap is too dirty or the hole is deep enough.  Don't forget to use tapping fluid!" -- thanks Dad. </p><p><img src="https://cdn.hackaday.io/images/2919201436244779535.jpg"></p><p>Following the above advice can really lead to some very successfully tapped holes. </p><p><img src="https://cdn.hackaday.io/images/7346301436244633499.jpg"></p><p>While Makerslide provides a very solid slide and carriage, we still need a way to transfer linear motion from a stepper motor to that carriage.  I prefer using lead screws for this application rather than belts since the load can rest on the leadscrew, even when the stepper motor isn't powered.  Here I've put together a small printable nut holder that low-profile enough to live between the Makerslide and the carriage, and attach with normal M5 extrusion bolts and t-slot nuts. </p><p><img src="https://cdn.hackaday.io/images/438471436244643691.jpg"></p><p>A nylon M8 nut very snugly fits into the back of the nut holder. </p><p><img src="https://cdn.hackaday.io/images/7029401436244654457.jpg"></p><p>Allowing an M8 threaded nylon rod to be threaded through, and used to transfer linear motion. </p><p><img src="https://cdn.hackaday.io/images/4521301436244664616.jpg"></p><p>While the nylon might seem like an unusual material to use for transferring linear motion, it tends to have a small amount of mechanical play that allows it to self-align when coupled with a rigid linear rail like the Makerslide.  I've used traditional steel threaded rod before, but I've found that the small diameter rod tends to bend very easily (even while shipping), and it makes alignment and binding a constant issue.  The nylon solves this issue, has a very low friction and wear without lubrication, and is very inexpensive. </p><p><img src="https://cdn.hackaday.io/images/7693761436244675277.jpg"></p><p>Here the printed nut holder can be seen sandwiched between the carriage that it's bolted to, and the Makerslide rail. </p><p><img src="https://cdn.hackaday.io/images/366831436244686512.jpg"></p><p>The holder is designed to mate with the footprint on a <a href="https://www.inventables.com/technologies/standard-wheel-carriage-plate" target="_blank">standard wheel carriage plate</a>, to make the linear motion system as rigid and off-the-shelf as possible. </p><p><img src="https://cdn.hackaday.io/images/2702791436244705155.jpg"></p><p>At the bottom, the four NEMA14 motors have been replaced with three NEMA17 motors from <a href="http://www.adafruit.com/products/324" target="_blank">Adafruit</a> -- two for the two Makeslide rails, and one to rotate the table.  Since the two motors for the linear rail system move in unison, all three motors can be connected to a single Arduino motor shield. <img src="https://cdn.hackaday.io/images/3602121436244719379.jpg"></p><p>Two 10cm pieces of Misumi aluminum extrusion bridge the gap between the carriages, and provide a solid surface to mount both the detector array (on one side) and the Barium-133 radioisotope source (on the other).  The table mock-up is currently just a 3 inch disk, but eventually will need a proper mechanism that couples to the sample container, as well as a bearing to restrict the motion of any off-balance samples. </p><p><img src="https://cdn.hackaday.io/images/8178201436341488069.gif"></p><p>And it works!  With a very smooth motion, on both the linear and rotational axes. </p><p>Thanks for reading!</p></div>
                            </div>
                        </li>
                    
                        <li>
                            <h2><a href="/project/5946/log/22756-a-new-imaging-array-and-quarterfinals-video">A new imaging array, and quarterfinals video!</a></h2>
                            <small class="authorship">4 days ago  &bull;
                                <a class="gray-link" href="/project/5946/log/22756#discussion-list">
                                    1 comment
                                </a>
                                </small>
                            <div style="position:relative">
                                <div id="post-body-22756"><p>This is probably the strangest video anyone has ever made about computed tomography scanners, or entered into the Hackaday Prize.  But last year&apos;s videos were so serious, so I decided to have a little fun this year.  </p><iframe width="640" height="360" src="https://www.youtube.com/embed/jnVSIs4g4OY?rel=0" frameborder="0" allowfullscreen=""></iframe><p>I had the opportunity to make four more detectors while filming the quarterfinals video, and and filmed the atypical parts of the build process, including the wrapping (both with the electrical tape and conductive tape shield), as well as the ground wire installation.  I&apos;d like to put together a longer video that illustrates these processes, to make it easier for folks working to build their own detectors.</p><p><img src="https://cdn.hackaday.io/images/9122331439536903686.jpg"></p><p>Changing the sample container size from 2 inches to 3 inches in diameter caused a full design revision for mechanical issues, including the imaging array board.  Below the new imaging array board can be seen holding four of the sixteen total detectors.  A new microcontroller board should arrive in the next few days to drive this board, so that we can get back to imaging!</p><p><img src="https://cdn.hackaday.io/images/7260591439536915328.jpg"></p><p>Similarly, to accommodate the new imaging array board, the linear motion system on the mechanical platform had to become 6mm larger.  This is visually indistinguishable in the pictures, but meant the entire rig had to be disassembled and reassembled using new (slightly differently patterned) laser cut parts. </p><p>While filming, I had the opportunity to put the tomographic platform together, and hope to also put together a timelapse video illustrating this process for folks interested in constructing their own. </p><p><img src="https://cdn.hackaday.io/images/7319041439536924735.jpg"></p><p>Just a quick update, and a little less frequent than normal (I was on vacation back home in Canada for a few weeks!), but stay tuned -- thanks for reading!</p></div>
                            </div>
                        </li>
                    
                </ul>

                

                

                </p>

            
        </div>
    </div>

    










<div class="footer" id="footer">
  <a href="#header" class="back-to-top" onClick="CT(this, 'Footer', 'GoingUp');">^ Going up? ^</a>
    <div class="container">
        <p><a href="http://hackaday.com/about/">About Us</a> <a href="mailto:projects-contact@hackaday.com">Contact Us</a> <a href="/project/37">Give Feedback</a>&copy; 2015 Hackaday <a href="/tos">Terms of Use</a> <a href="/privacy-policy">Privacy Policy</a></p>
        <a href="/" class="had-skull"  onClick="CT(this, 'Footer', 'Home' ); return false;">Hackaday.io</a>
    </div>
</div>

<script>

    var csrftoken = 'vQJ4BVpR-YMY7I59dIIksxbrm5hT676SCBQs';

</script>

    <script type="text/javascript">

    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-47229708-1', 'auto');

    var dimensionValue = 'nonregistered';
    ga('set', 'dimension1', dimensionValue);
    ga('require', 'displayfeatures');

    ga('send', 'pageview');

    </script>

<img src="//analytics.supplyframe.com/trackingservlet/impression?action=pageImpression&amp;zone=HIO_logs&amp;extra=logged%3Dfalse%7ChaveAccountCookie%3D0%7C&amp;ab=undefined" class="sf-impression" />

    
    
    <script src="//cdn.hackaday.io/build/h%2FydgsYIeDTf7pqgYQEKK8Ngblw0IkZCDqfJ9S2tk7zsBoxIHt5iOd49Qp%2BF4vdxEuRj%2BGpGDLbX4aGOQGmbjaOxUZvklg4ReFk68R95OQshFrGKebvogKGQOiB5Hi1xym9KC54c9Ps0WpzuNydLk4B%2FbKi91KhV40Uxhl38XXb1IVAxAI8iW%2BoQUPCFkHVWZxD0B%2BMZ%2BuEXJTlWuBmopNMxTHRK5yleITPZODT6evbVRQc6AXs9w2Pfk7FS2nKy-0.48.6.js"></script>

</body>
</html>